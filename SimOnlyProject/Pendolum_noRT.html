<doctype html>
<html>
<head>
<title>PendolumRT</title>

<script id="OBJ_Loader" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// .OBJ File Loader and parser
///////////////////////////////////////////////////////////////////////////////////

class ObjMesh
{
	constructor()
	{
		this.vpos = [];	// vertex positions
		this.face = [];	// face vertex indices
		this.tpos = [];	// texture coordinates
		this.tfac = [];	// face texture coordinate indices
		this.norm = [];	// surface normals
		this.nfac = [];	// face surface normal indices
	}
	
	// Reads the obj file at the given URL and parses it.
	load( url )
	{
		var xhttp = new XMLHttpRequest();
		xhttp.onreadystatechange = function() {
			if (this.readyState == 4 && this.status == 200) {
				parse( this.responseText );
			}
		};
		xhttp.open("GET", url, true);
		xhttp.send();
	}
	
	// Parses the contents of an obj file.
	parse( objdata )
	{
		var lines = objdata.split('\n');
		for ( var i=0; i<lines.length; ++i ) {
			var line = lines[i].trim();
			var elem = line.split(/\s+/);
			switch ( elem[0][0] ) {
				case 'v':
					switch ( elem[0].length ) {
						case 1:
							this.vpos.push( [ parseFloat(elem[1]), parseFloat(elem[2]), parseFloat(elem[3]) ] );
							break;
						case 2:
							switch ( elem[0][1] ) {
								case 't':
									this.tpos.push( [ parseFloat(elem[1]), parseFloat(elem[2]) ] );
									break;
								case 'n':
									this.norm.push( [ parseFloat(elem[1]), parseFloat(elem[2]), parseFloat(elem[3]) ] );
									break;
							}
							break;
					}
					break;
				case 'f':
					var f=[], tf=[], nf=[];
					for ( var j=1; j<elem.length; ++j ) {
						var ids = elem[j].split('/');
						var vid = parseInt(ids[0]);
						if ( vid < 0 ) vid = this.vpos.length + vid + 1;
						f.push( vid - 1 );
						if ( ids.length > 1 && ids[1] !== "" ) {
							var tid = parseInt(ids[1]);
							if ( tid < 0 ) tid = this.tpos.length + tid + 1;
							tf.push( tid - 1 );
						}
						if ( ids.length > 2 && ids[2] !== "" ) {
							var nid = parseInt(ids[2]);
							if ( nid < 0 ) nid = this.norm.length + nid + 1;
							nf.push( nid - 1 );
						}
					}
					this.face.push(f);
					if ( tf.length ) this.tfac.push(tf);
					if ( nf.length ) this.nfac.push(nf);
					break;
			}
		}
	}
	
	// Returns the bounding box of the object
	getBoundingBox()
	{
		if ( this.vpos.length == 0 ) return null;
		var min = [...this.vpos[0]];
		var max = [...this.vpos[0]];
		for ( var i=1; i<this.vpos.length; ++i ) {
			for ( var j=0; j<3; ++j ) {
				if ( min[j] > this.vpos[i][j] ) min[j] = this.vpos[i][j];
				if ( max[j] < this.vpos[i][j] ) max[j] = this.vpos[i][j];
			}
		}		
		return { min: min, max: max };
	}

	// Returns the center of the mesh object	
	getCenterOfMesh()
	{
		let sumX = 0, sumY = 0, sumZ = 0;
		let numVertices = this.vpos.length;
		for (let i = 0; i < this.vpos.length; i++) {
			sumX += this.vpos[i][0];
			sumY += this.vpos[i][1];
			sumZ += this.vpos[i][2];
		}
		let middleX = sumX / numVertices;
		let middleY = sumY / numVertices;
		let middleZ = sumZ / numVertices;
		return [middleX, middleY, middleZ];
	}
	
	shiftAndScale( shift, scale )
	{
		for ( var i=0; i<this.vpos.length; ++i ) {
			for ( var j=0; j<3; ++j ) {				
				this.vpos[i][j] = (this.vpos[i][j] + shift[j]) * scale;
			}
		}
	}
	
	computeNormals()
	{
		function add( a, b ) {
			return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
		}

		function sub( a, b ) {
			return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
		}

		function dot( a, b ) {
			return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
		}

		function cross( a, b ) {
			return [ a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0] ];
		}
		
		function normalize( a ) {
			var len = Math.sqrt( dot(a,a) );
			return [ a[0]/len, a[1]/len, a[2]/len ];
		}
		
		if ( this.nfac.length == 0 || this.norm.length == 0 ) {
			this.nfac = this.face;
			this.norm.length = this.vpos.length;
		}
		for ( var i=0; i<this.norm.length; ++i ) this.norm[i] = [0,0,0];
		for ( var i=0; i<this.face.length; ++i ) {
			var f = this.face[i];
			var nf = this.nfac[i];
			var v0 = this.vpos[ f[0] ];
			for ( var j=1; j<f.length-1; ++j ) {
				var v1 = this.vpos[ f[j] ];
				var v2 = this.vpos[ f[j+1] ];
				var e0 = sub( v1, v0 );
				var e1 = sub( v2, v0 );
				var n  = cross( e0, e1 );
				n = normalize(n);
				this.norm[ nf[0  ] ] = add( this.norm[ nf[0  ] ], n );
				this.norm[ nf[j  ] ] = add( this.norm[ nf[j  ] ], n );
				this.norm[ nf[j+1] ] = add( this.norm[ nf[j+1] ], n );
			}
		}
		for ( var i=0; i<this.norm.length; ++i ) this.norm[i] = normalize(this.norm[i]);
	}
	
	getVertexBuffers()
	{
		function addTriangleToBuffers( mesh, fi, i, j, k )
		{
			var f  = mesh.face[fi];
			var tf = mesh.tfac[fi];
			var nf = mesh.nfac[fi];
			addTriangleToBuffer( vBuffer, mesh.vpos, f, i, j, k, addVertToBuffer3 );
			if ( tf ) {
				addTriangleToBuffer( tBuffer, mesh.tpos, tf, i, j, k, addVertToBuffer2 );
			}
			if ( nf ) {
				addTriangleToBuffer( nBuffer, mesh.norm, nf, i, j, k, addVertToBuffer3 );
			}
		}
		
		function addTriangleToBuffer( buffer, v, f, i, j, k, addVert )
		{
			addVert( buffer, v, f, i );
			addVert( buffer, v, f, j );
			addVert( buffer, v, f, k );
		}
		
		function addVertToBuffer3( buffer, v, f, i )
		{
			buffer.push( v[f[i]][0] );
			buffer.push( v[f[i]][1] );
			buffer.push( v[f[i]][2] );
		}

		function addVertToBuffer2( buffer, v, f, i )
		{
			buffer.push( v[f[i]][0] );
			buffer.push( v[f[i]][1] );
		}
	
		var vBuffer = [];
		var tBuffer = [];
		var nBuffer = [];
		
		for ( var i=0; i<this.face.length; ++i ) {
			if ( this.face[i].length < 3 ) continue;
			addTriangleToBuffers( this, i, 0, 1, 2 );
			for ( var j=3; j<this.face[i].length; ++j ) {
				addTriangleToBuffers( this, i, 0, j-1, j );
			}
		}
		
		return { positionBuffer: vBuffer, texCoordBuffer: tBuffer, normalBuffer: nBuffer };
	}

	getElementBuffers()
	{
		function setBuffer( buffer, i, data, dim )
		{
			for ( var d=0, k=i*dim; d<dim; ++d, ++k ) buffer[k] = data[d];
		}
		
		var vBuffer = [];
		var tBuffer = [];
		var nBuffer = [];
		var eBuffer = [];

		vBuffer.length = this.vpos.length * 3;
		for ( var i=0; i<this.vpos.length; ++i ) {
			setBuffer( vBuffer, i, this.vpos[i], 3 );
		}
		tBuffer.length = this.vpos.length * 2;
		nBuffer.length = this.vpos.length * 3;
		tBuffer.fill(0);
		nBuffer.fill(0);

		function addTriangleToBuffers( mesh, fi, i, j, k )
		{
			addVertexToBuffers( mesh, fi, i );
			addVertexToBuffers( mesh, fi, j );
			addVertexToBuffers( mesh, fi, k );
		}
		
		function addVertexToBuffers( mesh, fi, i )
		{
			var f  = mesh.face[fi];
			var tf = mesh.tfac[fi];
			var nf = mesh.nfac[fi];
			eBuffer.push( f[i] );
			setBuffer( tBuffer, f[i], mesh.tpos[ tf[i] ], 2 );
			setBuffer( nBuffer, f[i], mesh.norm[ nf[i] ], 3 );
		}

		for ( var i=0; i<this.face.length; ++i ) {
			if ( this.face[i].length < 3 ) continue;
			addTriangleToBuffers( this, i, 0, 1, 2 );
			for ( var j=3; j<this.face[i].length; ++j ) {
				addTriangleToBuffers( this, i, 0, j-1, j );
			}
		}

		return { elementBuffer: eBuffer, positionBuffer: vBuffer, texCoordBuffer: tBuffer, normalBuffer: nBuffer };
	}
}
</script>

<script id="Rope_Drawer" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Rope Drawer, draws rope from cealing to the center of pendulum
///////////////////////////////////////////////////////////////////////////////////

class RopeDrawer {
    constructor()
      {
        this.vertPos = [];           

		this.ropeVShader =
   				`attribute vec3 coordinates;
   				uniform mat4 mvp;
   				   void main() {   				               
   				               gl_Position = mvp * vec4(coordinates,1.0);
   				           }
   				               `;
  		this.ropeFShader =
 				`
 				void main(void) {
 				    gl_FragColor = vec4(1,0,1,1);
 				            }  
 				`;

				
          // Compile the shader program
          this.prog = InitShaderProgram( this.ropeVShader, this.ropeFShader );
          
          // Get the ids of the uniform variables in the shaders
          this.mvp = gl.getUniformLocation( this.prog, 'mvp' );
  
          // Get the ids of the vertex attributes in the shaders
          this.coordPos = gl.getAttribLocation( this.prog, 'coordinates' );
          
          // Create the buffer objects
          this.vertexBuffer = gl.createBuffer();
        }
            	
    setRope(pos){		
        this.vertPos = [
			pos[0].x, pos[0].y, pos[0].z,
			pos[1].x, pos[1].y, pos[1].z];        

		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
		gl.bufferData(
			gl.ARRAY_BUFFER, 
			new Float32Array(this.vertPos), 
			gl.STATIC_DRAW
		);		
    }

    // draw rope
    draw( trans ) //trans --> mvp
      {	
		if(this.vertPos.length == 0) return;						
              gl.useProgram( this.prog );
              gl.uniformMatrix4fv( this.mvp, false, trans );
              gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
              gl.vertexAttribPointer( this.coordPos, 3, gl.FLOAT, false, 0, 0 );
              gl.enableVertexAttribArray( this.coordPos );
              gl.disable(gl.DEPTH_TEST);
              gl.drawArrays( gl.LINES, 0, 2 );
              gl.enable(gl.DEPTH_TEST);
      }
  }

</script>

<script id="Help_FXs" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// some FX to hande things not well defined yet...
///////////////////////////////////////////////////////////////////////////////////

// return the index of the Vertex in the mesh
// that is higher in the Y axis

function getRopeVertex(vertPos) {
  let maxY = -2;
  let index = -1;
  console.log(vertPos.length, "VertPos Length");
  for (let i = 0; i < vertPos.length; i += 3) {
    if (vertPos[i + 1] > maxY) {
      maxY = vertPos[i + 1];
      index = i;
    }
  }
  return index;
}

// return the coordinates of the center of the mesh
function getCenterOfMesh(vertPos) {
  let sumX = 0,
    sumY = 0,
    sumZ = 0;
  let numVertices = vertPos.length / 3;
  for (let i = 0; i < vertPos.length; i += 3) {
    sumX += vertPos[i];
    sumY += vertPos[i + 1];
    sumZ += vertPos[i + 2];
  }
  let middleX = sumX / numVertices;
  let middleY = sumY / numVertices;
  let middleZ = sumZ / numVertices;
  return [middleX, middleY, middleZ];
}

// fx for pendolum.updateMesh()
function addTriangleToBuffer(buffer, bi, vals, i, j, k) {
        buffer[bi++] = vals[i].x;
        buffer[bi++] = vals[i].y;
        buffer[bi++] = vals[i].z;
        buffer[bi++] = vals[j].x;
        buffer[bi++] = vals[j].y;
        buffer[bi++] = vals[j].z;
        buffer[bi++] = vals[k].x;
        buffer[bi++] = vals[k].y;
        buffer[bi++] = vals[k].z;
      }

// fx for pendolum.updateMesh()
function updateBuffer(buffer, faces, verts) {      
  for (var i = 0, bi = 0; i < faces.length; ++i) {
    var f = faces[i];
    if (f.length < 3) continue;
    addTriangleToBuffer(buffer, bi, verts, f[0], f[1], f[2]);
    bi += 9;
    for (var j = 3; j < f.length; ++j, bi += 9) {
      addTriangleToBuffer(buffer, bi, verts, f[0], f[j - 1], f[j]);
    }
  }
    }
</script>

<script id="Mesh__Drawer_from_EX7" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Mesh Drawer from EX7
///////////////////////////////////////////////////////////////////////////////////
class MeshDrawer {
  constructor() {
    this.swap = false;
    this.showTex = true;
    this.loadTex = false;
    this.vertPos = [];
    this.texCoords = [];
    this.normals = [];
    this.shininess = 0;
    this.lightDir = [0.0, 0.0, 0.0];
    this.numTriangles = 0;
    this.positionBuffer = gl.createBuffer();
    this.txcBuffer = gl.createBuffer();
    this.mytex = gl.createTexture();
    this.normBuffer = gl.createBuffer();

    // MODEL/OBJECT SPACE --> VIEW/CAMERA SPACE
    // p' = MV * p
    // n' = MN * n
    // MN = (MV)^-1 (inverse-transpose of matrixMV)
    this.meshVS = `
		  attribute vec3 pos;			
		attribute vec2 txc; 	  
	  attribute vec3 norm;
  
	  uniform mat4 mvp;		    
	  uniform mat4 modelViewMx;
	  uniform mat3 normalMx;
		  uniform float swapYZ;
		
		  varying vec4 vPositions;
	  varying vec3 vNormals;
	  varying vec2 texCoord;
  
	  void main() 
		  {
			  gl_Position = mvp * vec4(swapYZ == 1.0 ? pos.xzy : pos , 1);					      
		vPositions = modelViewMx * vec4(swapYZ == 1.0 ? pos.xzy : pos, 1);
		vNormals = normalMx * (swapYZ == 1.0 ? norm.xzy : norm);
		texCoord = txc;
		  }
		  `;

    // BLINN SHADING
    // use hVector instead of rVector
    // vec3 reflectDir = reflect(-lightDir, normal);

    this.meshFS = `
		uniform sampler2D tex;  
		  precision mediump float;	    
		   
	  uniform float loadTex;
		   uniform float showTex;
  
	  uniform float shininess;
	  uniform vec3 vLightDir;
		
	  varying vec2 texCoord;
	  varying vec3 vNormals;
	  varying vec4 vPositions;
		  
	  void main()
		  {
		
		vec3 viewDir = normalize(-vPositions.xyz);
		vec3 normal = normalize(vNormals);
		vec3 lightDir = normalize(vLightDir);
		vec3 halfDir = normalize(lightDir + viewDir);       
		
		vec3 lightIntensity = vec3(1.0, 1.0, 1.0);      
		vec3 ambient =  lightIntensity * vec3(0.1, 0.1, 0.1);
		vec3 Kd = vec3(1.0, 1.0, 1.0);
		vec3 Ks = vec3(1.0, 1.0, 1.0);
		
  
		if( loadTex == 1.0 && showTex == 1.0){
		  Kd = texture2D(tex, texCoord).xyz;  
		  ambient = lightIntensity * Kd * 0.1;
		}    
		
		float phiCos = max(0.0, dot(normal, halfDir));
		float thetaCos = max(0.0, dot(normal, lightDir));
			  
		vec3 diffuse = thetaCos * Kd;
		vec3 specular = pow(phiCos, shininess) * Ks;    
		
		gl_FragColor = vec4(ambient + diffuse + specular, 1.0);      
	  }
		  `;

    // compile shader Program
    this.prog = InitShaderProgram(this.meshVS, this.meshFS);

    // get the location of the uniform variable
    this.mvp = gl.getUniformLocation(this.prog, "mvp");
    this.vrtxPos = gl.getAttribLocation(this.prog, "pos");
    this.texture = gl.getUniformLocation(this.prog, "tex");
    this.txcPos = gl.getAttribLocation(this.prog, "txc");
    this.swapPos = gl.getUniformLocation(this.prog, "swapYZ");
    this.loadTexPos = gl.getUniformLocation(this.prog, "loadTex");
    this.showTexPos = gl.getUniformLocation(this.prog, "showTex");
    // shader positions
    this.normPos = gl.getAttribLocation(this.prog, "norm");
    this.shininessPos = gl.getUniformLocation(this.prog, "shininess");
    this.lightDirPos = gl.getUniformLocation(this.prog, "vLightDir");
    this.mvMx = gl.getUniformLocation(this.prog, "modelViewMx");
    this.normMx = gl.getUniformLocation(this.prog, "normalMx");
  }

  setMesh(vertPos, texCoords, normals) {
    this.numTriangles = vertPos.length / 3;
    this.vertPos = vertPos;
    this.texCoords = texCoords;
    this.normals = normals;
    // allocate data on GPU memory
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(this.vertPos),
      gl.STATIC_DRAW
    );
    gl.bindBuffer(gl.ARRAY_BUFFER, this.txcBuffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(this.texCoords),
      gl.STATIC_DRAW
    );
    gl.bindBuffer(gl.ARRAY_BUFFER, this.normBuffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(this.normals),
      gl.STATIC_DRAW
    );
  }

  draw(matrixMVP, matrixMV, matrixNormal) {
    // clear the canvas
    //gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(this.prog);
    // set Uniforms
    gl.uniformMatrix4fv(this.mvp, false, matrixMVP);
    gl.uniformMatrix4fv(this.mvMx, false, matrixMV);
    gl.uniformMatrix3fv(this.normMx, false, matrixNormal);
    gl.uniform1f(this.swapPos, this.swap ? 1.0 : 0.0);
    gl.uniform1f(this.loadTexPos, this.loadTex ? 1.0 : 0.0);
    gl.uniform1f(this.showTexPos, this.showTex ? 1.0 : 0.0);
    gl.uniform1f(this.shininessPos, this.shininess);
    gl.uniform3fv(this.lightDirPos, this.lightDir);
    // send texture to shader
    gl.uniform1i(this.texture, 0);
    // init vrtxPos with buffer
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.vertexAttribPointer(this.vrtxPos, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.vrtxPos);
    // init txcPos with buffer
    gl.bindBuffer(gl.ARRAY_BUFFER, this.txcBuffer);
    gl.vertexAttribPointer(this.txcPos, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.txcPos);
    // init normPos with buffer
    gl.bindBuffer(gl.ARRAY_BUFFER, this.normBuffer);
    gl.vertexAttribPointer(this.normPos, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.normPos);
    // draw	                       
    gl.drawArrays(gl.TRIANGLES, 0, this.numTriangles);	
  }

  // If you perform shading in the camera space,
  // you do not need to transform the light direction
  setLightDir(x, y, z) {
    this.lightDir = [x, y, z];
  }

  setShininess(shininess) {
    this.shininess = shininess;
  }

  setTexture(img) {
    if (img != null) {
      this.loadTex = true;

      gl.bindTexture(gl.TEXTURE_2D, this.mytex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
      gl.generateMipmap(gl.TEXTURE_2D);

      // filters
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(
        gl.TEXTURE_2D,
        gl.TEXTURE_MIN_FILTER,
        gl.LINEAR_MIPMAP_LINEAR
      );

      // binding
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.mytex);
    } else this.loadTex = false;
  }

  showTexture(show) {
    this.showTex = show;
  }

  swapYZ(swap) {
    this.swap = swap;
  }
}

</script>

<script id="WhiteBox__Drawer" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Draw the white BOX
///////////////////////////////////////////////////////////////////////////////////
class BoxDrawer {
	constructor()
	{
		// Compile the shader program
		this.prog = InitShaderProgram( boxVS, boxFS );
		
		// Get the ids of the uniform variables in the shaders
		this.mvp = gl.getUniformLocation( this.prog, 'mvp' );
		
		// Get the ids of the vertex attributes in the shaders
		this.vertPos = gl.getAttribLocation( this.prog, 'pos' );
		
		// Create the buffer objects
		
		this.vertbuffer = gl.createBuffer();
		var pos = [
			-1, -1, -1,
			-1, -1,  1,
			-1,  1, -1,
			-1,  1,  1,
			 1, -1, -1,
			 1, -1,  1,
			 1,  1, -1,
			 1,  1,  1 ];
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertbuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);

		this.linebuffer = gl.createBuffer();
		var line = [
			0,1,   1,3,   3,2,   2,0,
			4,5,   5,7,   7,6,   6,4,
			0,4,   1,5,   3,7,   2,6 ];
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.linebuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(line), gl.STATIC_DRAW);
	}
	draw( trans )
	{
		// Draw the line segments
		gl.useProgram( this.prog );
		gl.uniformMatrix4fv( this.mvp, false, trans );
		gl.bindBuffer( gl.ARRAY_BUFFER, this.vertbuffer );
		gl.vertexAttribPointer( this.vertPos, 3, gl.FLOAT, false, 0, 0 );
		gl.enableVertexAttribArray( this.vertPos );
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.linebuffer );
		gl.drawElements( gl.LINES, 24, gl.UNSIGNED_BYTE, 0 );
	}
}
// Vertex shader source code
var boxVS = `
	attribute vec3 pos;
	uniform mat4 mvp;
	void main()
	{
		gl_Position = mvp * vec4(pos,1);
	}
`;
// Fragment shader source code
var boxFS = `
	precision mediump float;
	void main()
	{
		gl_FragColor = vec4(1,1,1,1);
	}
`;
///////////////////////////////////////////////////////////////////////////////////
</script>

<script id="mouseOver__PointDrawer" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Draw MouseOver Vertex in RED
///////////////////////////////////////////////////////////////////////////////////
class PointDrawer {
	constructor()
	{
		// Compile the shader program
		this.prog = InitShaderProgram( pointVS, pointFS );
		
		// Get the ids of the uniform variables in the shaders
		this.mvp = gl.getUniformLocation( this.prog, 'mvp' );

		// Get the ids of the vertex attributes in the shaders
		this.vertPos = gl.getAttribLocation( this.prog, 'pos' );
		
		// Create the buffer objects
		this.vertbuffer = gl.createBuffer();
	}
	setPoint(p)
	{
		if ( this.selVertex == p ) return false;
		this.selVertex = p;
		this.updatePoint();
		return true;
	}
	updatePoint()
	{
		if ( this.selVertex !== undefined ) {
			var pos = [ this.selVertex.x, this.selVertex.y, this.selVertex.z ];
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertbuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);
		}
	}
	draw( trans )
	{
		if ( this.selVertex ) {
			gl.useProgram( this.prog );
			gl.uniformMatrix4fv( this.mvp, false, trans );
			gl.bindBuffer( gl.ARRAY_BUFFER, this.vertbuffer );
			gl.vertexAttribPointer( this.vertPos, 3, gl.FLOAT, false, 0, 0 );
			gl.enableVertexAttribArray( this.vertPos );
			gl.disable(gl.DEPTH_TEST);
			gl.drawArrays( gl.POINTS, 0, 1 );
			gl.enable(gl.DEPTH_TEST);
		}
	}
}
// Vertex shader source code
var pointVS = `
	attribute vec3 pos;
	uniform mat4 mvp;
	void main()
	{
		gl_Position = mvp * vec4(pos,1);
		gl_PointSize = 10.0;
	}
`;
// Fragment shader source code
var pointFS = `
	precision mediump float;
	void main()
	{
		gl_FragColor = vec4(1,0,0,1);
	}
`;
///////////////////////////////////////////////////////////////////////////////////
</script>

<script id="viewMatricesFX" type="text/javascript">	
///////////////////////////////////////////////////////////////////////////////////
// some functions to handle the view matrices
///////////////////////////////////////////////////////////////////////////////////
function ProjectionMatrix( c, z, fov_angle=60 )
{
	var r = c.width / c.height;
	var n = (z - 1.74);
	const min_n = 0.001;
	if ( n < min_n ) n = min_n;
	var f = (z + 1.74);;
	var fov = 3.145 * fov_angle / 180;
	var s = 1 / Math.tan( fov/2 );
	return [
		s/r, 0, 0, 0,
		0, s, 0, 0,
		0, 0, (n+f)/(f-n), 1,
		0, 0, -2*n*f/(f-n), 0
	];
}

// from PROJECT_7
function GetModelViewMatrix(translationX,translationY,translationZ,rotationX,rotationY)
{
  	// first column
  	let a = Math.cos(rotationY);
  	let c = -Math.sin(rotationY);
  	// second column
  	let e = Math.sin(rotationY) * Math.sin(rotationX);
  	let f = Math.cos(rotationX);
  	let g = Math.cos(rotationY) * Math.sin(rotationX);
  	// third column
  	let i = Math.sin(rotationY) * Math.cos(rotationX);
  	let j = -Math.sin(rotationX);
  	let k = Math.cos(rotationY) * Math.cos(rotationX);

  	var mv = [
  	  a,
  	  0,
  	  c,
  	  0,
  	  e,
  	  f,
  	  g,
  	  0,
  	  i,
  	  j,
  	  k,
  	  0,
  	  translationX,
  	  translationY,
  	  translationZ,
  	  1,
  	];

  	return mv;
}

// Multiplies two matrices and returns the result A*B.
// The arguments A and B are arrays, representing column-major matrices.
function MatrixMult( A, B )
{
	var C = Array(16);
	for ( var i=0, m=0; i<4; ++i ) {
		for ( var j=0; j<4; ++j, ++m ) {
			var v = 0;
			for ( var k=0; k<4; ++k ) {
				v += A[j+4*k] * B[k+4*i];
			}
			C[m] = v;
		}
	}
	return C;
}

// Returns the inverse of the given 4x4 matrix
function MatrixInverse( m )
{
	var r = Array(16);
	
	var v_11_14__10_15 = m[11] * m[14] - m[10] * m[15];
	var v_10_15__11_14 = m[10] * m[15] - m[11] * m[14];
	var v__7_14___6_15 = m[ 7] * m[14] - m[ 6] * m[15];
	var v__6_11___7_10 = m[ 6] * m[11] - m[ 7] * m[10];

	var v__9_15__11_13 = m[ 9] * m[15] - m[11] * m[13];
	var v_11_13___9_15 = m[11] * m[13] - m[ 9] * m[15];
	var v__5_15___7_13 = m[ 5] * m[15] - m[ 7] * m[13];
	var v__7__9___5_11 = m[ 7] * m[ 9] - m[ 5] * m[11];
	
	var v_10_13___9_14 = m[10] * m[13] - m[ 9] * m[14];
	var v__9_14__10_13 = m[ 9] * m[14] - m[10] * m[13];
	var v__6_13___5_14 = m[ 6] * m[13] - m[ 5] * m[14];
	var v__5_10___6__9 = m[ 5] * m[10] - m[ 6] * m[ 9];
	
	var v_11_12___8_15 = m[11] * m[12] - m[ 8] * m[15];
	var v__8_15__11_12 = m[ 8] * m[15] - m[11] * m[12];
	var v__7_12___4_15 = m[ 7] * m[12] - m[ 4] * m[15];
	var v__4_11___7__8 = m[ 4] * m[11] - m[ 7] * m[ 8];
	
	var v__8_14__10_12 = m[ 8] * m[14] - m[10] * m[12];
	var v_10_12___8_14 = m[10] * m[12] - m[ 8] * m[14];
	var v__4_14___6_12 = m[ 4] * m[14] - m[ 6] * m[12];
	var v__6__8___4_10 = m[ 6] * m[ 8] - m[ 4] * m[10];
	
	var v__9_12___8_13 = m[ 9] * m[12] - m[ 8] * m[13];
	var v__8_13___9_12 = m[ 8] * m[13] - m[ 9] * m[12];
	var v__5_12___4_13 = m[ 5] * m[12] - m[ 4] * m[13];
	var v__4__9___5__8 = m[ 4] * m[ 9] - m[ 5] * m[ 8];

	r[ 0] = m[5] * (-v_11_14__10_15) + m[6] * (-v__9_15__11_13) + m[7] * (-v_10_13___9_14);
	r[ 1] = m[1] * (-v_10_15__11_14) + m[2] * (-v_11_13___9_15) + m[3] * (-v__9_14__10_13);
	r[ 2] = m[1] * (-v__7_14___6_15) + m[2] * (-v__5_15___7_13) + m[3] * (-v__6_13___5_14);
	r[ 3] = m[1] * (-v__6_11___7_10) + m[2] * (-v__7__9___5_11) + m[3] * (-v__5_10___6__9);
	
	r[ 4] = m[4] * ( v_11_14__10_15) + m[6] * (-v_11_12___8_15) + m[7] * (-v__8_14__10_12);
	r[ 5] = m[0] * ( v_10_15__11_14) + m[2] * (-v__8_15__11_12) + m[3] * (-v_10_12___8_14);
	r[ 6] = m[0] * ( v__7_14___6_15) + m[2] * (-v__7_12___4_15) + m[3] * (-v__4_14___6_12);
	r[ 7] = m[0] * ( v__6_11___7_10) + m[2] * (-v__4_11___7__8) + m[3] * (-v__6__8___4_10);
	
	r[ 8] = m[4] * ( v__9_15__11_13) + m[5] * ( v_11_12___8_15) + m[7] * (-v__9_12___8_13);
	r[ 9] = m[0] * ( v_11_13___9_15) + m[1] * ( v__8_15__11_12) + m[3] * (-v__8_13___9_12);
	r[10] = m[0] * ( v__5_15___7_13) + m[1] * ( v__7_12___4_15) + m[3] * (-v__5_12___4_13);
	r[11] = m[0] * ( v__7__9___5_11) + m[1] * ( v__4_11___7__8) + m[3] * (-v__4__9___5__8);

	r[12] = m[4] * ( v_10_13___9_14) + m[5] * ( v__8_14__10_12) + m[6] * ( v__9_12___8_13);
	r[13] = m[0] * ( v__9_14__10_13) + m[1] * ( v_10_12___8_14) + m[2] * ( v__8_13___9_12);
	r[14] = m[0] * ( v__6_13___5_14) + m[1] * ( v__4_14___6_12) + m[2] * ( v__5_12___4_13);
	r[15] = m[0] * ( v__5_10___6__9) + m[1] * ( v__6__8___4_10) + m[2] * ( v__4__9___5__8);

	var det = m[0]*r[0] + m[1]*r[4] + m[2]*r[8] + m[3]*r[12];
	for ( var i=0; i<16; ++i ) r[i] /= det;
	
	return r;
}

</script>

<script id="CORE_WebGL_InitFX" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below is the core WebGL initialization code.
///////////////////////////////////////////////////////////////////////////////////

var boxDrawer;
var pointDrawer;
var meshDrawers;
var ropeDrawers;
var nSpheres = 5;
var canvas, gl;
// initial camera Positions
var rotX=0, rotY=0, transY=0, transZ=3;
var MV, MVP; // view matrices

// Called once to initialize
function InitWebGL()
{
	// Initialize the WebGL canvas
	canvas = document.getElementById("canvas");
	canvas.oncontextmenu = function() {return false;};
	gl = canvas.getContext("webgl", {antialias: false, depth: true});	// Initialize the GL context
	if (!gl) {
		alert("Unable to initialize WebGL. Your browser or machine may not support it.");
		return;
	}
	
	// Initialize settings
	gl.clearColor(0,0,0,0);
	gl.enable(gl.DEPTH_TEST);
	
	// Initialize the programs and buffers for drawing		
	boxDrawer   = new BoxDrawer();
	pointDrawer = new PointDrawer();
	meshDrawers = [];
	ropeDrawers = [];
	for (var i = 0; i < nSpheres; i++) {				
		meshDrawers.push(new MeshDrawer());
		ropeDrawers.push(new RopeDrawer());
	}
	
	// Set the viewport size
	UpdateCanvasSize();
}

// Called every time the window size is changed.
function UpdateCanvasSize()
{
	canvas.style.width  = "100%";
	canvas.style.height = "100%";
	const pixelRatio = window.devicePixelRatio || 1;
	canvas.width  = pixelRatio * canvas.clientWidth;
	canvas.height = pixelRatio * canvas.clientHeight;
	const width  = (canvas.width  / pixelRatio);
	const height = (canvas.height / pixelRatio);
	canvas.style.width  = width  + 'px';
	canvas.style.height = height + 'px';
	gl.viewport( 0, 0, canvas.width, canvas.height );
	UpdateViewMatrices();
}

function UpdateViewMatrices()
{
	var perspectiveMatrix = ProjectionMatrix( canvas, transZ );
	MV  = GetModelViewMatrix( 0, transY, transZ, rotX, rotY );
	MVP = MatrixMult( perspectiveMatrix, MV );
}

// This is the main function that handled WebGL drawing
function DrawScene()
{
	// Clear the screen and the depth buffer.
	gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
	
	// Draw the curve and then the line segments that connect the control points.
	var nrmTrans = [ MV[0],MV[1],MV[2], MV[4],MV[5],MV[6], MV[8],MV[9],MV[10] ];		

	if( showMesh.checked )
		for( var i=0; i<nSpheres; i++ )
			meshDrawers[i].draw( MVP, MV, nrmTrans );					
	if ( showBox.checked ) 
		boxDrawer.draw( MVP );	
	if( showRope.checked )
		for( var i=0; i<nSpheres; i++ )
			ropeDrawers[i].draw( MVP );		
	pointDrawer.draw( MVP );
}

// This is a helper function for compiling the given vertex and fragment shader source code into a program.
function InitShaderProgram( vsSource, fsSource, wgl=gl )
{
	const vs = CompileShader( wgl.VERTEX_SHADER,   vsSource, wgl );
	const fs = CompileShader( wgl.FRAGMENT_SHADER, fsSource, wgl );

	const prog = wgl.createProgram();
	wgl.attachShader(prog, vs);
	wgl.attachShader(prog, fs);
	wgl.linkProgram(prog);

	if (!wgl.getProgramParameter(prog, wgl.LINK_STATUS)) {
		alert('Unable to initialize the shader program: ' + wgl.getProgramInfoLog(prog));
		return null;
	}
	return prog;
}

// This is a helper function for compiling a shader, called by InitShaderProgram().
function CompileShader( type, source, wgl=gl )
{
	const shader = wgl.createShader(type);
	wgl.shaderSource(shader, source);
	wgl.compileShader(shader);
	if (!wgl.getShaderParameter( shader, wgl.COMPILE_STATUS) ) {
		alert('An error occurred compiling shader:\n' + wgl.getShaderInfoLog(shader));
		wgl.deleteShader(shader);
		return null;
	}
	return shader;
}

</script>

<script id="lightControlCode" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below is the light view control code
///////////////////////////////////////////////////////////////////////////////////

var lightView;

class LightView
{
	constructor()
	{
		this.canvas = document.getElementById("lightcontrol");
		this.canvas.oncontextmenu = function() {return false;};
		this.gl = this.canvas.getContext("webgl", {antialias: false, depth: true});	// Initialize the GL context
		if (!this.gl) {
			alert("Unable to initialize WebGL. Your browser or machine may not support it.");
			return;
		}
		
		// Initialize settings
		this.gl.clearColor(0.33,0.33,0.33,0);
		this.gl.enable(gl.DEPTH_TEST);
		
		this.rotX = 0;
		this.rotY = 0;
		this.posZ = 5;
		
		this.resCircle = 32;
		this.resArrow = 16;
		this.buffer = this.gl.createBuffer();
		var data = [];
		for ( var i=0; i<=this.resCircle; ++i ) {
			var a = 2 * Math.PI * i / this.resCircle;
			var x = Math.cos(a);
			var y = Math.sin(a);
			data.push( x * .9 );
			data.push( y * .9 );
			data.push( 0 );
			data.push( x );
			data.push( y );
			data.push( 0 );
		}
		for ( var i=0; i<=this.resCircle; ++i ) {
			var a = 2 * Math.PI * i / this.resCircle;
			var x = Math.cos(a);
			var y = Math.sin(a);
			data.push( x );
			data.push( y );
			data.push( -.05 );
			data.push( x );
			data.push( y );
			data.push( 0.05 );
		}
		for ( var i=0; i<=this.resArrow; ++i ) {
			var a = 2 * Math.PI * i / this.resArrow;
			var x = Math.cos(a) * .07;
			var y = Math.sin(a) * .07;
			data.push( x );
			data.push( y );
			data.push( -1 );
			data.push( x );
			data.push( y );
			data.push( 0 );
		}
		data.push( 0 );
		data.push( 0 );
		data.push( -1.2 );
		for ( var i=0; i<=this.resArrow; ++i ) {
			var a = 2 * Math.PI * i / this.resArrow;
			var x = Math.cos(a) * .15;
			var y = Math.sin(a) * .15;
			data.push( x );
			data.push( y );
			data.push( -0.9 );
		}
		this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
		this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(data), this.gl.STATIC_DRAW);
		
		// Set the viewport size
		this.canvas.style.width  = "";
		this.canvas.style.height = "";
		const pixelRatio = window.devicePixelRatio || 1;
		this.canvas.width  = pixelRatio * this.canvas.clientWidth;
		this.canvas.height = pixelRatio * this.canvas.clientHeight;
		const width  = (this.canvas.width  / pixelRatio);
		const height = (this.canvas.height / pixelRatio);
		this.canvas.style.width  = width  + 'px';
		this.canvas.style.height = height + 'px';
		this.gl.viewport( 0, 0, this.canvas.width, this.canvas.height );
		this.proj = ProjectionMatrix( this.canvas, this.posZ, 30 );
		
		// Compile the shader program
		this.prog = InitShaderProgram( lightViewVS, lightViewFS, this.gl );
		this.mvp = this.gl.getUniformLocation( this.prog, 'mvp' );
		this.clr1 = this.gl.getUniformLocation( this.prog, 'clr1' );
		this.clr2 = this.gl.getUniformLocation( this.prog, 'clr2' );
		this.vertPos = this.gl.getAttribLocation( this.prog, 'pos' );
		
		this.draw();
		this.updateLightDir();
		
		this.canvas.onmousedown = function() {
			var cx = event.clientX;
			var cy = event.clientY;
			lightView.canvas.onmousemove = function() {
				lightView.rotY += (cx - event.clientX)/lightView.canvas.width*5;
				lightView.rotX += (cy - event.clientY)/lightView.canvas.height*5;
				cx = event.clientX;
				cy = event.clientY;
				lightView.draw();
				lightView.updateLightDir();
			}
		}
		this.canvas.onmouseup = this.canvas.onmouseleave = function() {
			lightView.canvas.onmousemove = null;
		}
	}
	
	updateLightDir()
	{
		var cy = Math.cos( this.rotY );
		var sy = Math.sin( this.rotY );
		var cx = Math.cos( this.rotX );
		var sx = Math.sin( this.rotX );
		for( var i=0; i<nSpheres; i++ )
			meshDrawers[i].setLightDir( -sy, cy*sx, -cy*cx );
		//meshDrawer.setLightDir( -sy, cy*sx, -cy*cx );
		DrawScene();
	}
	
	draw()
	{
		// Clear the screen and the depth buffer.
		this.gl.clear( this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT );
		
		this.gl.bindBuffer( this.gl.ARRAY_BUFFER, this.buffer );
		this.gl.vertexAttribPointer( this.vertPos, 3, this.gl.FLOAT, false, 0, 0 );
		this.gl.enableVertexAttribArray( this.buffer );

		this.gl.useProgram( this.prog );
		var mvp = MatrixMult( this.proj, [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,this.posZ,1 ] );
		this.gl.uniformMatrix4fv( this.mvp, false, mvp );
		this.gl.uniform3f( this.clr1, 0.6,0.6,0.6 );
		this.gl.uniform3f( this.clr2, 0,0,0 );
		this.gl.drawArrays( this.gl.TRIANGLE_STRIP, 0, this.resCircle*2+2 );

		var mv  = GetModelViewMatrix( 0, 0, this.posZ, this.rotX, this.rotY );
		var mvp = MatrixMult( this.proj, mv );
		this.gl.uniformMatrix4fv( this.mvp, false, mvp );
		this.gl.uniform3f( this.clr1, 1,1,1 );
		this.gl.drawArrays( this.gl.TRIANGLE_STRIP, 0, this.resCircle*2+2 );
		this.gl.drawArrays( this.gl.TRIANGLE_STRIP, this.resCircle*2+2, this.resCircle*2+2 );
		this.gl.uniform3f( this.clr1, 0,0,0 );
		this.gl.uniform3f( this.clr2, 1,1,1 );
		this.gl.drawArrays( this.gl.TRIANGLE_STRIP, this.resCircle*4+4, this.resArrow*2+2 );
		this.gl.drawArrays( this.gl.TRIANGLE_FAN, this.resCircle*4+4 + this.resArrow*2+2, this.resArrow+2 );
	}
}

// Vertex shader source code
const lightViewVS = `
	attribute vec3 pos;
	uniform mat4 mvp;
	void main()
	{
		gl_Position = mvp * vec4(pos,1);
	}
`;
// Fragment shader source code
var lightViewFS = `
	precision mediump float;
	uniform vec3 clr1;
	uniform vec3 clr2;
	void main()
	{
		gl_FragColor = gl_FrontFacing ? vec4(clr1,1) : vec4(clr2,1);
	}
`;
///////////////////////////////////////////////////////////////////////////////////
</script>

<script id="PendolumSimulationCode" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Simulation of One Pendolum, with 1 center of Mass and one Cealing Point...
///////////////////////////////////////////////////////////////////////////////////

var pendolum;

class Pendolum
{
	constructor()
	{
		this.gravity = new Vec3( 0, -2.0, 0 );
		this.mass = .1;								
		this.stiffness = 1; // rigidit√†			
		this.restitution = .8; // restituzione
		this.damping = 1; // smorzamento
		this.freeRest = false; // lunghezza bloccata/Libera					
		this.simType = 1; // 1sim, 2sim, 3sim
		this.meshes = new Array(nSpheres);
		this.vPositions = new Array(nSpheres);
		this.vVelocities = new Array(nSpheres);
		this.normals = new Array(nSpheres);
		this.buffers = new Array(nSpheres);
		this.rPositions = new Array(nSpheres);
		this.rVelocities = new Array(nSpheres);
		this.pRestLength = new Array(nSpheres);
		this.boundingBox = undefined; // bounding box of the mesh before the shift
		this.loadedMesh = document.getElementById('box.obj').text; // loaded mesh when change sim type
		this.setMesh( this.loadedMesh );					
	}
			
	// ++ this.mesh = new ObjMesh;
	/// this.vpos = [];	// vertex positions
	/// this.face = [];	// face vertex indices
	/// this.tpos = [];	// texture coordinates
	/// this.tfac = [];	// face texture coordinate indices
	/// this.norm = [];	// surface normals
	/// this.nfac = [];	// face surface normal indices
	setMesh( objdef )
	{
		var postShift = new Array(nSpheres);
		if(this.simType == 1 )
		{			
			//postShift[0] = [0.4,0,0];
			postShift[0] = [
				0.8561327732253686,
				0.1101320176931324,
				0.0
			];
			postShift[1] = [0.2,0,0];
			postShift[2] = [0,0,0];
			postShift[3] = [-0.2,0,0];
			postShift[4] = [-0.4,0,0];
		}
		else if(this.simType == 2)
		{
			postShift[0] = [
				0.8561327732253686,
				0.1101320176931324,
				0.0
			];
			let numbX = 0.8561327732253686 - 0.2;
			postShift[1] = [
				numbX,
				0.1101320176931324,
				0.0
			];
			postShift[2] = [0,0,0];
			postShift[3] = [-0.2,0,0];
			postShift[4] = [-0.4,0,0];			
		}
		else if(this.simType == 3)
		{
			postShift[0] = [
				0.8561327732253686,
				0.1101320176931324,
				0.0
			];
			let numbX = 0.8561327732253686 - 0.2;
			postShift[1] = [
				numbX,
				0.1101320176931324,
				0.0
			];
			let numbXX = numbX - 0.2;
			postShift[2] = [
				numbXX,
				0.1101320176931324,
				0.0
			];
			postShift[3] = [-0.2,0,0];
			postShift[4] = [-0.4,0,0];
		}	
		for( var i=0; i<nSpheres; ++i ) {
			this.meshes[i] = new ObjMesh;
			this.meshes[i].parse( objdef );
			var box = this.meshes[i].getBoundingBox();			
			var shift = [
				-(box.min[0]+box.max[0])/2,
				-(box.min[1]+box.max[1])/2,
				-(box.min[2]+box.max[2])/2
			];						
			var size = [
				(box.max[0]-box.min[0])/2,
				(box.max[1]-box.min[1])/2,
				(box.max[2]-box.min[2])/2
			];			
			var maxSize = Math.max( size[0], size[1], size[2] );
			var scale = 0.1/maxSize;
			this.meshes[i].shiftAndScale( shift, scale );
			if(i == 2)// save before the shift
				this.boundingBox = this.meshes[i].getBoundingBox();	
			console.log(this.boundingBox);		
			this.meshes[i].shiftAndScale( postShift[i], 1 );
			this.meshes[i].computeNormals();			
		}
		/*
		{
		this.mesh = new ObjMesh;
		this.mesh.parse( objdef );
		var box = this.mesh.getBoundingBox();
		var shift = [
			-(box.min[0]+box.max[0])/2,
			-(box.min[1]+box.max[1])/2,
			-(box.min[2]+box.max[2])/2
		];
		var size = [
			(box.max[0]-box.min[0])/2,
			(box.max[1]-box.min[1])/2,
			(box.max[2]-box.min[2])/2
		];
		var maxSize = Math.max( size[0], size[1], size[2] );
		var scale = 0.1/maxSize;
		this.mesh.shiftAndScale( shift, scale );
		this.mesh.computeNormals();
		}
		*/
		this.reset();
		this.initPendolumRest();
		DrawScene();		
	}
	
	// ++ this.buffers = this.mesh.getVertexBuffers();
	/// { positionBuffer: vBuffer, texCoordBuffer: tBuffer, normalBuffer: nBuffer };
	// ++ this.pos = Array(2);
	/// this.pos[0] = new Vec3( 0, 1, 0 );	// cealing
	/// this.pos[1] = new Vec3( 0, 0, 0 );	// center of mass
	// ++ this.vel = Array(2);
	/// this.vel[0] = new Vec3( 0, 0, 0 );
	/// this.vel[1] = new Vec3( 0, 0, 0 );
	// ++ this.nrm = Array(this.mesh.norm.length);	
	reset()
	{		
		if(this.simType == 1)
		{
			this.rPositions[0] = 
			[											
				new Vec3(0.4,1,0),
				new Vec3(
					0.8561327732253686,
					0.1101320176931324,
					0.0
				)
			];					
			this.rPositions[1] = 
			[
				new Vec3(0.2,1,0),
				new Vec3(0.2,0,0)
			];
			this.rPositions[2] = [
				new Vec3(0,1,0),
				new Vec3(0,0,0)
			];
			this.rPositions[3] = [
				new Vec3(-0.2,1,0),
				new Vec3(-0.2,0,0)
			];
			this.rPositions[4] = [
				new Vec3(-0.4,1,0),
				new Vec3(-0.4,0,0)
			];
		}
		else if(this.simType == 2)
		{
			this.rPositions[0] = [
				new Vec3(0.4,1,0),
				new Vec3(0.8561327732253686,
					0.1101320176931324,
					0.0)
			];
			let numbX = 0.8561327732253686 - 0.2;
			this.rPositions[1] = [
				new Vec3(0.2,1,0),
				new Vec3(numbX,
					0.1101320176931324,
					0.0)			
			];
			this.rPositions[2] = [
				new Vec3(0,1,0),
				new Vec3(0,0,0)
			];
			this.rPositions[3] = [
				new Vec3(-0.2,1,0),
				new Vec3(-0.2,0,0)
			];
			this.rPositions[4] = [
				new Vec3(-0.4,1,0),
				new Vec3(-0.4,0,0)
			];
		}
		else
		{
			this.rPositions[0] = [
				new Vec3(0.4,1,0),
				new Vec3(0.8561327732253686,
					0.1101320176931324,
					0.0)
			];
			let numbX = 0.8561327732253686 - 0.2;
			this.rPositions[1] = [
				new Vec3(0.2,1,0),
				new Vec3(numbX,
					0.1101320176931324,
					0.0)			
			];
			let numbXX = numbX - 0.2;
			this.rPositions[2] = [
				new Vec3(0,1,0),
				new Vec3(numbXX,
					0.1101320176931324,
					0.0)
			];
			this.rPositions[3] = [
				new Vec3(-0.2,1,0),
				new Vec3(-0.2,0,0)
			];
			this.rPositions[4] = [
				new Vec3(-0.4,1,0),
				new Vec3(-0.4,0,0)
			];
		}
		for( var i=0; i<nSpheres; ++i ) {
			this.vPositions[i] = Array(this.meshes[i].vpos.length);
			for ( var j=0; j<this.vPositions[i].length; ++j ) 
				this.vPositions[i][j] = ToVec3(this.meshes[i].vpos[j]);
			this.vVelocities[i] = Array(this.vPositions[i].length);
			for ( var j=0; j<this.vVelocities[i].length; ++j ) 
				this.vVelocities[i][j] = new Vec3( 0, 0, 0 );
			this.normals[i] = Array(this.meshes[i].norm.length);
			for ( var j=0; j<this.normals[i].length; ++j ) 
				this.normals[i][j] = ToVec3(this.meshes[i].norm[j]);			
			
			this.rVelocities[i] = [new Vec3(0,0,0),new Vec3(0,0,0)];
			// Update the mesh drawers and Rope Drawers
			this.buffers[i] = this.meshes[i].getVertexBuffers();			
			ropeDrawers[i].setRope(this.rPositions[i]);
			meshDrawers[i].setMesh(
				this.buffers[i].positionBuffer,
				this.buffers[i].texCoordBuffer,
				this.buffers[i].normalBuffer
			);
		}				
		/*
		{
		this.vpos = Array(this.mesh.vpos.length);
		for ( var i=0; i<this.vpos.length; ++i ) this.vpos[i] = ToVec3(this.mesh.vpos[i]);
		this.vvel = Array(this.vpos.length);
		for ( var i=0; i<this.vvel.length; ++i ) this.vvel[i] = new Vec3( 0, 0, 0 );
		this.nrm = Array(this.mesh.norm.length);
    	for (var i = 0; i < this.nrm.length; ++i) this.nrm[i] = ToVec3(this.mesh.norm[i]);

		this.rpos = [new Vec3(0,1,0),new Vec3(0,0,0)];
		this.rvel = [new Vec3(0,0,0),new Vec3(0,0,0)]; 				   
			
		ropeDrawer.setRope(this.rpos);
		this.buffers = this.mesh.getVertexBuffers();
    	meshDrawer.setMesh(this.buffers.positionBuffer,this.buffers.texCoordBuffer,this.buffers.normalBuffer);
		
		}
		*/		
	}

	//initialize the pendolum length
	initPendolumRest() {  					
		this.pRestLength.fill(1.0);
		//var r = this.rPositions[i][0].sub(this.rPositions[i][1]).len();		
	}


	startSimulation()
	{		
		if ( ! this.isSimulationRunning() ) 
			this.timer = setInterval
			( 
				function(){ pendolum.step(); }, 
				document.getElementById('timestep').value 
			);
	}
	isSimulationRunning() { return this.timer !== undefined; }
	stopSimulation(){clearInterval( this.timer );this.timer = undefined;}
	restartSimulation() { if ( this.isSimulationRunning() ) { this.stopSimulation(); this.startSimulation(); } }
	toggleSimulation( btn )
	{
		if (this.isSimulationRunning() ) {
			this.stopSimulation();
			btn.value = "Start Simulation";
		} else {
			this.startSimulation();
			btn.value = "Stop Simulation";
		}
	}
	
	setSimulation(param){		
		this.simType = param.value;		
		this.setMesh( this.loadedMesh );
		this.reset();
		this.initPendolumRest();
		DrawScene();
	}
	
	
	updateMesh() {    
		for( var i=0; i<nSpheres; ++i ) {
			// update the position buffer
			updateBuffer(
				this.buffers[i].positionBuffer,
				this.meshes[i].face,
				this.vPositions[i]
			);
			
			// update normals
			for (var j = 0; j < this.normals[i].length; ++j) 
				this.normals[i][j].init(0, 0, 0);
			for (var j = 0; j < this.meshes[i].face.length; ++j) {
				var f = this.meshes[i].face[j];
				var nf = this.meshes[i].nfac[j];
				var v0 = this.vPositions[i][f[0]];
				for (var k = 1; k < f.length - 1; ++k) {
					var v1 = this.vPositions[i][f[k]];
					var v2 = this.vPositions[i][f[k + 1]];
					var e0 = v1.sub(v0);
					var e1 = v2.sub(v0);
					var n = e0.cross(e1);
					n = n.unit();
					this.normals[i][nf[0]].inc(n);
					this.normals[i][nf[k]].inc(n);
					this.normals[i][nf[k + 1]].inc(n);
				}
			}
			for (var j = 0; j < this.normals[i].length; ++j) 
				this.normals[i][j].normalize();
			updateBuffer(
				this.buffers[i].normalBuffer,
				this.meshes[i].nfac,
				this.normals[i]
			);

			// Update the mesh,Rope
			ropeDrawers[i].setRope(this.rPositions[i]);
			meshDrawers[i].setMesh(
				this.buffers[i].positionBuffer,
				this.buffers[i].texCoordBuffer,
				this.buffers[i].normalBuffer
			);
		}
		// update Point Drawer and redraw scene
		pointDrawer.updatePoint();
		DrawScene();		
	/*
	{
    // update the position buffer
    updateBuffer(this.buffers.positionBuffer, this.mesh.face, this.vpos);

    // update normals
    for (var i = 0; i < this.nrm.length; ++i) this.nrm[i].init(0, 0, 0);
    for (var i = 0; i < this.mesh.face.length; ++i) {
      var f = this.mesh.face[i];
      var nf = this.mesh.nfac[i];
      var v0 = this.vpos[f[0]];
      for (var j = 1; j < f.length - 1; ++j) {
        var v1 = this.vpos[f[j]];
        var v2 = this.vpos[f[j + 1]];
        var e0 = v1.sub(v0);
        var e1 = v2.sub(v0);
        var n = e0.cross(e1);
        n = n.unit();
        this.nrm[nf[0]].inc(n);
        this.nrm[nf[j]].inc(n);
        this.nrm[nf[j + 1]].inc(n);
      }
    }
    for (var i = 0; i < this.nrm.length; ++i) this.nrm[i].normalize();
    updateBuffer(this.buffers.normalBuffer, this.mesh.nfac, this.nrm);

    // Update the mesh,Rope,Point Drawer and redraw scene
    ropeDrawer.setRope(this.rpos);
	meshDrawer.setMesh(
      this.buffers.positionBuffer,
      this.buffers.texCoordBuffer,
      this.buffers.normalBuffer
    );	
    pointDrawer.updatePoint();

    DrawScene();
  }
	*/	
	}

  	copyholdVert() {
		if(Array.isArray(this.holdVert)){
			let holdVert = Array(this.holdVert.length);
		for( var i=0; i<this.holdVert.length; ++i )
			holdVert[i] = this.holdVert[i].copy();
			return holdVert;
		}else{
			return this.holdVert.copy();
		}		
	}
	setholdVert( holdVert ) {
		if(Array.isArray(holdVert)){
			this.holdVert = Array(holdVert.length);		
			for( var i=0; i<holdVert.length; ++i )
				this.holdVert[i] = holdVert[i].copy();
		}else{
			this.holdVert.set(holdVert);
		}
	}

	step()
	{
		// holdVert ==> List of CenterOFmass + all vertex of one mesh
		// selRope ==> selected pendolum
		 // remember the position of the selected vertex, if any		 
		 var p = this.holdVert ? this.copyholdVert() : undefined;
		 // Update positions and velocities
		 var timestep = document.getElementById("timestep").value;
		 const dt = timestep / 1000; // time step in seconds	
		 const damping = this.damping * this.stiffness * dt;	 	 
		 PendolumStep(
					  dt,
					  this.rPositions,
					  this.rVelocities,
					  this.vPositions,
					  this.vVelocities,
					  this.pRestLength,					  
					  this.mass,
					  this.gravity,
					  this.restitution,
					  damping,
					  this.stiffness,
					  // mesh without shifts for Collision Detection
					  //this.meshes[2].getBoundingBox()
					  this.boundingBox
					);
					
		// make sure that the selected vertex does not change position			
		if (p) {
			// 8 vertici + 1 centro(array) || 1 cealing(Vec3)
			//console.log("p: ", p); 	
			// [numeroPendolo, cealing | center of mass]
			//console.log(this.selRope, "this.selRope");
			this.setholdVert(p);

			let pendolumNum = this.selRope[0];			
			// stop movement of the selected pendolum						
			this.rVelocities[pendolumNum][1].init(0, 0, 0);				
			for ( var i=0; i<this.vVelocities[pendolumNum].length; ++i )			
				this.vVelocities[pendolumNum][i].init(0, 0, 0);				
		}
		this.updateMesh();
	}	
	 	
	mouseMove()
	{						
		var m = MousePos();
		this.selRope = undefined;
		var selPt;
		var minDist = 10;
		for ( var i=0; i<this.rPositions.length; ++i ) {
			for( var j=0; j<this.rPositions[i].length; ++j ) {
				var p = this.rPositions[i][j];
				var pv = p.trans(MVP);
				var px = pv.x / pv.w;
				var py = pv.y / pv.w;
				var dx = m.x - px;
				var dy = m.y - py;
				var len2 = dx*dx + dy*dy;
				if ( len2 < 0.001 && len2 < minDist ) {
					minDist = len2;
					this.selRope = [i,j];
					selPt = p;
				}
			}
		}		
		if ( pointDrawer.setPoint( selPt ) ) {
			DrawScene();
			canvas.className = selPt ? "sel" : "";
		}					
	}	
	mouseDown()
	{					
		if ( this.selRope === undefined ) return false;
		// [numeroPendolo, cealing | center of mass]
		var mInv = MatrixInverse(MVP);	
		var pendolumNum = this.selRope[0];			
		var p = this.rPositions[pendolumNum][ this.selRope[1] ];				
		var pv = p.trans(MVP);				

		// save for Later...
		if(this.selRope[1] === 1){
			this.holdVert = new Array(this.vPositions[pendolumNum].length + 1);						
			this.holdVert[this.holdVert.length - 1] 
				= this.rPositions[ pendolumNum ][1].copy();				
			for( var i=0; i<this.vPositions[pendolumNum].length; ++i )
				this.holdVert[i] = this.vPositions[pendolumNum][i].copy();			
		}else{
			this.holdVert = this.rPositions[ pendolumNum ][0].copy();
		}
			
			
				
		function mouse4D()
		{
			var m = MousePos();
			return {
				x: m.x * pv.w,
				y: m.y * pv.w,
				z: pv.z,
				w: pv.w
			};
		}
		
		function invTrans(v)
		{
			return {
				x: mInv[0]*v.x + mInv[4]*v.y + mInv[ 8]*v.z + mInv[12]*v.w,
				y: mInv[1]*v.x + mInv[5]*v.y + mInv[ 9]*v.z + mInv[13]*v.w,
				z: mInv[2]*v.x + mInv[6]*v.y + mInv[10]*v.z + mInv[14]*v.w,
				w: mInv[3]*v.x + mInv[7]*v.y + mInv[11]*v.z + mInv[15]*v.w
			};
		}
		
		function mouse3D() { 
			var m = invTrans(mouse4D());
			return new Vec3( m.x/m.w, m.y/m.w, m.z/m.w );
		}
		
		var m0 = mouse3D();
		var ms = this;
		
		// Here moves the selected verteces and Center of Masses
		// Also Update length of the pendolum		
		// velocity is already set to 0, in step() function			
		canvas.onmousemove = function() {
			var m1 = mouse3D(); // mouse position 3D
			var d = m1.sub(m0); // mouse movement (before - after)
			m0 = { ...m1 }; // assign m1 to m0
			p.inc(d); // update selected pendolum 
					  // Rope position (cealing or center of mass)			
			
		  	// now update the mesh vertexes position
			// when center of mass is selected			
			if(ms.selRope[1] === 1)
				for( var i=0; i<ms.vPositions[pendolumNum].length; ++i ) 
					ms.vPositions[pendolumNum][i].inc(d);
											
			// update the pendolum rope/Rest Length		
			if(ms.freeRest){				
				ms.pRestLength[pendolumNum] = 
					ms.rPositions[pendolumNum][0]
					.sub(ms.rPositions[pendolumNum][1]).len();							
			}else{								
				ms.pRestLength[pendolumNum] = 1.0;	
			}
			// call for update
			ms.updateMesh();
		}
		return true;		
	}	
	mouseUp()
	{		
		this.holdVert = undefined;
	}
	
}

function PendolumStep(
	dt,
  	rPositions,
  	rVelocities, 
  	vPositions,  
  	vVelocities,
  	pRestLength,
  	particleMass,
  	gravity,
  	restitution,
	damping,
	stiffness,
  	box)
	{
	//console.log(rPositions,"rPositions");
	//console.log(rVelocities,"rVelocities");
	//console.log(springs,"springs");
	//console.log(stiffness,"stiffness");
	//console.log(damping,"damping");
	//console.log(particleMass,"particleMass");
	//console.log(gravity,"gravity");
	//console.log(restitution,"restitution");

	// just one for every center of mass 
	// (not counting cealing points)
	var forces = [...Array(rPositions.length)].map(
    (_, i) => new Vec3(0, gravity.y * particleMass, 0));	
	
	forces.forEach((forceVector, pNumb) => {				
		let p0Pos = rPositions[pNumb][0]; //Vec3		
		let p1Pos = rPositions[pNumb][1];
		let p1Vel = rVelocities[pNumb][1].len2();
		// ogni singolo errore introdotto al Dt precedente 
		// va ad accumularsi in ogni passo successivo...
		// quindi bisogna considerare initLength...
		// altrimenti la distorsione del pendolo aumenta
		let curLength = p1Pos.sub(p0Pos).len();	
		let restLength = pRestLength[pNumb];					
		let pendolDir = p1Pos.sub(p0Pos).unit();
		let orthoDir = pendolDir.cross(new Vec3(0, 1, 0)).unit();
		let cosTheta = pendolDir.dot(new Vec3(0, 1, 0));		
			
						
		// tension force => mg*cosTheta
		let tension = particleMass * gravity.y * (cosTheta);
		let tensionForceP0 = pendolDir.mul(tension);
		let tensionForceP1 = tensionForceP0.mul(-1);
		// Centripetal force => m*v^2/r
		let centripetal = particleMass * p1Vel / restLength ;
		let centripetalForceP0 = pendolDir.mul(centripetal);
		let centripetalForceP1 = centripetalForceP0.mul(-1);
		// spring force => stiffness*(l-l0)
		let springForceP0 = pendolDir.mul(stiffness * (curLength - restLength));
		let springForceP1 = springForceP0.mul(-1);
		// damping force => -damping*v		
		let lDamp = rVelocities[pNumb][1].dot(pendolDir);
		let dampingForceP0 = pendolDir.mul(damping * lDamp);
		let dampingForceP1 = dampingForceP0.mul(-1);
		

		forces[pNumb] = forces[pNumb]
		.add(tensionForceP1)
		.add(centripetalForceP1)
		.add(springForceP1)
		.add(dampingForceP1);

	});
	
	// Update positions and velocities 
	// of center of Mass & all vertex
	rVelocities.forEach((rVel, pNumb) => {		
		// Compute Acceleration for center of Mass...
		let acc = forces[pNumb].div(particleMass);
		// Semi-Implicit Euler Integration
		rVel[1].inc(acc.mul(dt));
		rPositions[pNumb][1].inc(rVel[1].mul(dt));
		// apply to all mesh vertexes
		vVelocities[pNumb].forEach((vVel, i) => {
			vVel.inc(acc.mul(dt));
			vPositions[pNumb][i].inc(vVel.mul(dt));
		});
	});
		
	// Collision Detection and Response

	/*

		let p0 = springs.p0;
		let p0Pos = rPositions[p0]; //Vec3
		let p0Vel = rVelocities[p0]; //Vec3
		let p1 = springs.p1;
		let p1Pos = rPositions[p1];
		let p1Vel = rVelocities[p1];		
		let lSpring = p1Pos.sub(p0Pos).len();		

		// tension force => mg*cosTheta
		// Centripetal force => m*v^2/r
		let tensionDir = p1Pos.sub(p0Pos).div(lSpring);
		let cosTheta = tensionDir.dot(new Vec3(0, 1, 0));			
		let v = p1Vel.len();// velocita' tangenziale
		let tension = particleMass * gravity.y * cosTheta;
		let centripetal = particleMass * v * v / lSpring;	
		let tensionForceP0 = tensionDir.mul(tension + centripetal);
		let tensionForceP1 = tensionForceP0.mul(-1);
		forces[p1] = forces[p1].add(tensionForceP1);	


  		// Compute Acceleration for ONLY ONE PARTICLE...
		var acc = forces[p1].div(particleMass);    	
  		// Semi-Implicit Euler Integration
		rVelocities[p1].inc(acc.mul(dt));	
		rPositions[p1].inc(rVelocities[p1].mul(dt));
		vVelocities.forEach((vel,i) => {
			vel.inc(acc.mul(dt));			
			vPositions[i].inc(vel.mul(dt));
		});
	*/

	let xMax = 1.0 - box.max[0], xMin = -1.0 - box.min[0];	
	let yMax = 1.0 - box.max[1], yMin = -1.0 - box.min[1];
	let zMax = 1.0 - box.max[2], zMin = -1.0 - box.min[2];			
	// Wall Detection center of mass
	// cealing has no collision
	rPositions.forEach((rPos, pNumb) => {
		let pos = rPos[1]; //center of mass		
		
		if(pos.x > xMax){
			let h = pos.x - xMax;
			rVelocities[pNumb][1] = rVelocities[pNumb][1].mul(-restitution);			
			pos.x -= h*restitution;			
			vPositions[pNumb].forEach((vPos, i) => {									  				
				vVelocities[pNumb][i] = vVelocities[pNumb][i].mul(-restitution);
				vPos.x -= h*restitution;			
			});
		}
		if(pos.x < xMin){
			let h = xMin - pos.x;			
			rVelocities[pNumb][1] = rVelocities[pNumb][1].mul(-restitution);
			pos.x += h*restitution;
			vPositions[pNumb].forEach((vPos, i) => {							
				vVelocities[pNumb][i] = vVelocities[pNumb][i].mul(-restitution);
				vPos.x += h*restitution;
			});
		}
		if(pos.y > yMax){			
			let h = pos.y - yMax;			
			rVelocities[pNumb][1] = rVelocities[pNumb][1].mul(-restitution);
			pos.y -= h*restitution;
			vPositions[pNumb].forEach((vPos, i) => {							
				vVelocities[pNumb][i] = vVelocities[pNumb][i].mul(-restitution);
				vPos.y -= h*restitution;
			});
		}
		if(pos.y < yMin){
			let h = yMin - pos.y;			
			rVelocities[pNumb][1] = rVelocities[pNumb][1].mul(-restitution);
			pos.y += h*restitution;
			vPositions[pNumb].forEach((vPos, i) => {							
				vVelocities[pNumb][i] = vVelocities[pNumb][i].mul(-restitution);
				vPos.y += h*restitution;
			});
		}
		if(pos.z > zMax){
			let h = pos.z - zMax;			
			rVelocities[pNumb][1] = rVelocities[pNumb][1].mul(-restitution);
			pos.z -= h*restitution;
			vPositions[pNumb].forEach((vPos, i) => {							
				vVelocities[pNumb][i] = vVelocities[pNumb][i].mul(-restitution);
				vPos.z -= h*restitution;
			});
		}
		if(pos.z < zMin){
			let h = zMin - pos.z;			
			rVelocities[pNumb][1] = rVelocities[pNumb][1].mul(-restitution);
			pos.z += h*restitution;
			vPositions[pNumb].forEach((vPos, i) => {							
				vVelocities[pNumb][i] = vVelocities[pNumb][i].mul(-restitution);
				vPos.z += h*restitution;
			});
		}
	});

	// handle collisions with other Center of Mass
	// when collision occurs ==> elastic collision 
	let minDist = box.max[0] - box.min[0];	
	rPositions.forEach((rPos, pNumb) => {		
		rPositions.forEach((rPos2, pNumb2) => {
			if(pNumb === pNumb2) return;
			let pos = rPos[1]; 
			let pos2 = rPos2[1]; 
			let dist = pos.sub(pos2).len();
			if(dist <= minDist){
				// elastic collision
				let normalDir = pos.sub(pos2).unit();				
				//normalDir = new Vec3(normalDir.x,0,0);
				let isHorizontal = normalDir.y === 0;
				//console.log("isHorizontal",isHorizontal);				
				let h = minDist - dist;
				let v1 = rVelocities[pNumb][1].dot(normalDir);
				let v2 = rVelocities[pNumb2][1].dot(normalDir);
				// same mass
				let u1 = v2, u2 = v1;
				// update ropes Pos & velocities				
				pos.inc(normalDir.mul(h));								
				pos2.inc(normalDir.mul(-h));				
				rVelocities[pNumb][1] = rVelocities[pNumb][1].sub(normalDir.mul(v1-u1));
				rVelocities[pNumb2][1] = rVelocities[pNumb2][1].sub(normalDir.mul(v2-u2));
				
				// update mesh Pos & velocities
				vPositions[pNumb].forEach((vPos, i) => {							
					let v = vVelocities[pNumb][i].dot(normalDir);		
					let u = v2;			
					vVelocities[pNumb][i] = vVelocities[pNumb][i].sub(normalDir.mul(v - u));
					vPos.inc(normalDir.mul(h));	
				});
				vPositions[pNumb2].forEach((vPos, i) => {								
					let v = vVelocities[pNumb2][i].dot(normalDir);		
					let u = v1;			
					vVelocities[pNumb2][i] = vVelocities[pNumb2][i].sub(normalDir.mul(v - u));
					vPos.inc(normalDir.mul(-h));
				});
			}
		});
	});
	
	//console.log(len,"len");
	//console.log(rPositions[0][1]);
	//console.log(rVelocities[1][1]);
	//console.log(rVelocities[2][1]);		
}


</script>

<script id="vec3" type="text/javascript">	
	///////////////////////////////////////////////////////////////////////////////////
	// Below is the Vec3 class definition
	///////////////////////////////////////////////////////////////////////////////////
	/*
	init(x,y,z): sets the x, y, and z coordinates to the given values.
	copy(): returns a copy of the vector object.
	set(v): sets the x, y, and z coordinates to the same values as the given vector v.
	inc(v): increments the x, y, and z coordinate values by adding the coordinate values of the given vector v.
	dec(v): decrements the x, y, and z coordinate values by subtracting the coordinate values of the given vector v.
	scale(f): multiplies the x, y, and z coordinates by the given scalar f.
	add(v): add the given vector v to this vector and returns the resulting vector.
	sub(v): subtracts the given vector v from this vector and returns the resulting vector.
	dot(v): computes the dot product of this vector and the given vector v and returns the resulting scalar.
	cross(v): computes the cross product of this vector and the given vector v and returns the resulting vector.
	mul(f): multiplies the vector by the given scalar f and returns the result.
	div(f): divides the vector by the given scalar f and returns the result.
	len2(): returns the squared length of the vector.
	len(): returns the length of the vector.
	unit(): returns the unit vector along the direction of this vector.
	toFix(n): returns a new vector with each coordinate rounded to n decimal places.
	normalize(): normalizes this vector, turning it into a unit vector.
	*/
	class Vec3 {
		constructor( x, y, z ) { this.init(x,y,z); }
		init( x, y, z ) { this.x=x; this.y=y; this.z=z; }
		copy ( ) { return new Vec3( this.x, this.y, this.z ); }
		set  (v) { this.x =v.x; this.y =v.y; this.z =v.z; }
		inc  (v) { this.x+=v.x; this.y+=v.y; this.z+=v.z; }
		dec  (v) { this.x-=v.x; this.y-=v.y; this.z-=v.z; }
		scale(f) { this.x*=f; this.y*=f; this.z*=f; }
		add  (v) { return new Vec3( this.x+v.x, this.y+v.y, this.z+v.z ); }
		sub  (v) { return new Vec3( this.x-v.x, this.y-v.y, this.z-v.z ); }
		dot  (v) { return this.x*v.x + this.y*v.y + this.z*v.z; }
		cross(v) { return new Vec3( this.y*v.z-this.z*v.y, this.z*v.x-this.x*v.z, this.x*v.y-this.y*v.x ); }
		mul  (f) { return new Vec3( this.x*f, this.y*f, this.z*f ); }
		div  (f) { return new Vec3( this.x/f, this.y/f, this.z/f ); }
		len2 ( ) { return this.dot(this); }
		len  ( ) { return Math.sqrt(this.len2()); }
		unit ( ) { return this.div(this.len()); }
		toFix( n ) { return new Vec3( this.x.toFixed(n), this.y.toFixed(n), this.z.toFixed(n) ); }
		normalize() {
			var l = this.len();
			this.x /= l;
			this.y /= l;
			this.z /= l;
		}
		trans(m) {
			return {
				x: m[0]*this.x + m[4]*this.y + m[ 8]*this.z + m[12],
				y: m[1]*this.x + m[5]*this.y + m[ 9]*this.z + m[13],
				z: m[2]*this.x + m[6]*this.y + m[10]*this.z + m[14],
				w: m[3]*this.x + m[7]*this.y + m[11]*this.z + m[15]
			};
		}
	}
	
	function ToVec3(a) { return new Vec3(a[0],a[1],a[2]); }
	
</script>

<script id="MASS_SPRING_SIM" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below is the mass-spring system code
///////////////////////////////////////////////////////////////////////////////////

var massSpring; // questo √® il riferimento alla simulazione che viene creato in window.onload()

function SimTimeStep(
  dt,
  positions,
  velocities,
  springs,
  stiffness,
  damping,
  particleMass,
  gravity,
  restitution
) {
  var forces = [...Array(positions.length)].map(
    (_, i) => new Vec3(0, gravity.y * particleMass, 0)
  );
  // Compute the total force of each particle
  springs.forEach((spring) => {
    // spring = {p0: , p1: , rest: }
    let p0 = spring.p0;
    let p0Pos = positions[p0]; //Vec3
    let p0Vel = velocities[p0]; //Vec3
    let p1 = spring.p1;
    let p1Pos = positions[p1];
    let p1Vel = velocities[p1];
    let restLength = spring.rest; //float
    // spring Force
    let lSpring = p1Pos.sub(p0Pos).len();
    let springDir = p1Pos.sub(p0Pos).div(lSpring);
    let springForceP0 = springDir.mul(stiffness * (lSpring - restLength));
    let springForceP1 = springForceP0.mul(-1);
    // damping force
    let lDamp = p1Vel.sub(p0Vel).dot(springDir);
    let dampForceP0 = springDir.mul(damping * lDamp);
    let dampForceP1 = dampForceP0.mul(-1);
    //console.log("P0",springForceP0, dampForceP0);
    //console.log("P1",springForceP1, dampForceP1);
    // total force
    forces[p0] = forces[p0].add(springForceP0).add(dampForceP0);
    forces[p1] = forces[p1].add(springForceP1).add(dampForceP1);
  });
  // Compute Acceleration for each particle
  let acc = forces.map((f) => f.div(particleMass));
  // Update positions and velocities
  velocities.forEach((vel, i) => {
    // Semi-Implicit Euler Integration ------------------------------------------        
    vel.inc(acc[i].mul(dt));    
    positions[i].inc(vel.mul(dt));
  });  
  // Handle collisions
  positions.forEach((pos, i) => {
    if (pos.y < -1.0) {
      let h = -1.0 - pos.y;
      pos.y = -1.0 + h*restitution;      
      velocities[i] = velocities[i].mul(-restitution);
    }
    if(pos.y > 1.0){
      let h = pos.y - 1.0;
      pos.y = 1.0 - h*restitution;
      velocities[i] = velocities[i].mul(-restitution);
    }
    if(pos.x < -1.0){
      let h = -1.0 - pos.x;
      pos.x = -1.0 + h*restitution;
      velocities[i] = velocities[i].mul(-restitution);
    }
    if(pos.x > 1.0){
      let h = pos.x - 1.0;
      pos.x = 1.0 - h*restitution;
      velocities[i] = velocities[i].mul(-restitution);
    }
    if(pos.z < -1.0){
      let h = -1.0 - pos.z;
      pos.z = -1.0 + h*restitution;
      velocities[i] = velocities[i].mul(-restitution);
    }
    if(pos.z > 1.0){
      let h = pos.z - 1.0;
      pos.z = 1.0 - h*restitution;
      velocities[i] = velocities[i].mul(-restitution);
    }
  });
}


class MassSpring {

	constructor()
	{
		this.gravity = new Vec3( 0, -2.0, 0 );
		this.mass = .1;
		this.stiffness = 1;
		this.damping = 1;
		this.restitution = .8;
		this.setMesh( document.getElementById('box.obj').text );
	}

	setMesh( objdef )
	{
		this.mesh = new ObjMesh;
		this.mesh.parse( objdef );
		var box = this.mesh.getBoundingBox();
		var shift = [
			-(box.min[0]+box.max[0])/2,
			-(box.min[1]+box.max[1])/2,
			-(box.min[2]+box.max[2])/2
		];
		var size = [
			(box.max[0]-box.min[0])/2,
			(box.max[1]-box.min[1])/2,
			(box.max[2]-box.min[2])/2
		];
		var maxSize = Math.max( size[0], size[1], size[2] );
		var scale = 0.4/maxSize;
		this.mesh.shiftAndScale( shift, scale );
		this.mesh.computeNormals();
		this.reset();
		this.initSprings();
		DrawScene();
	}
	
	
	reset()
	{
		this.pos = Array( this.mesh.vpos.length );
		for ( var i=0; i<this.pos.length; ++i ) this.pos[i] = ToVec3( this.mesh.vpos[i] );
		this.vel = Array( this.pos.length );
		for ( var i=0; i<this.vel.length; ++i ) this.vel[i] = new Vec3(0,0,0);
		this.nrm = Array( this.mesh.norm.length );
		for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i] = ToVec3( this.mesh.norm[i] );
		this.buffers = this.mesh.getVertexBuffers();
		meshDrawer.setMesh( this.buffers.positionBuffer, this.buffers.texCoordBuffer, this.buffers.normalBuffer );
	}

	updateMesh()
	{
		function updateBuffer( buffer, faces, verts )
		{
			function addTriangleToBuffer( buffer, bi, vals, i, j, k )
			{
				buffer[bi++] = vals[i].x;
				buffer[bi++] = vals[i].y;
				buffer[bi++] = vals[i].z;
				buffer[bi++] = vals[j].x;
				buffer[bi++] = vals[j].y;
				buffer[bi++] = vals[j].z;
				buffer[bi++] = vals[k].x;
				buffer[bi++] = vals[k].y;
				buffer[bi++] = vals[k].z;
			}

			for ( var i=0, bi=0; i<faces.length; ++i ) {
				var f = faces[i];
				if ( f.length < 3 ) continue;
				addTriangleToBuffer( buffer, bi, verts, f[0], f[1], f[2] );
				bi += 9;
				for ( var j=3; j<f.length; ++j, bi+=9 ) {
					addTriangleToBuffer( buffer, bi, verts, f[0], f[j-1], f[j] );
				}
			}
		}
		
		// update the position buffer
		updateBuffer( this.buffers.positionBuffer, this.mesh.face, this.pos );
		
		// update normals
		for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i].init(0,0,0);
		for ( var i=0; i<this.mesh.face.length; ++i ) {
			var f = this.mesh.face[i];
			var nf = this.mesh.nfac[i];
			var v0 = this.pos[ f[0] ];
			for ( var j=1; j<f.length-1; ++j ) {
				var v1 = this.pos[ f[j] ];
				var v2 = this.pos[ f[j+1] ];
				var e0 = v1.sub(v0);
				var e1 = v2.sub(v0);
				var n  = e0.cross(e1);
				n = n.unit();
				this.nrm[ nf[0  ] ].inc(n);
				this.nrm[ nf[j  ] ].inc(n);
				this.nrm[ nf[j+1] ].inc(n);
			}
		}
		for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i].normalize();
		updateBuffer( this.buffers.normalBuffer, this.mesh.nfac, this.nrm );

		// Update the mesh drawer and redraw scene
		meshDrawer.setMesh( this.buffers.positionBuffer, this.buffers.texCoordBuffer, this.buffers.normalBuffer );

		pointDrawer.updatePoint();
		DrawScene();
	}

	simTimeStep()
	{
		// remember the position of the selected vertex, if any
		var p = this.holdVert ? this.holdVert.copy() : undefined;

		// Update positions and velocities
		var timestep = document.getElementById('timestep').value;
		const dt = timestep / 1000;	// time step in seconds
		const damping = this.damping * this.stiffness * dt;		
		///////////////////////////////////////////////////////////////////////////////////
		// Here the TimeStep Simulation Code from EX7
		// It updates the given positions and velocities
		SimTimeStep( dt, this.pos, this.vel, this.springs, this.stiffness, damping, this.mass, this.gravity, this.restitution );						
		///////////////////////////////////////////////////////////////////////////////////

		// make sure that the selected vertex does not change position
		if ( p ) {
			this.holdVert.set(p);
			this.vel[ this.selVert ].init(0,0,0);
		}
		
		this.updateMesh();
	}
	
	initSprings()
	{
		this.springs = [];
		for ( var i=0; i<this.pos.length; ++i ) {
			for ( var j=i+1; j<this.pos.length; ++j ) {
				var r = this.pos[i].sub(this.pos[j]).len();
				if ( r > .02 ) 
				{
					this.springs.push( { p0:i, p1:j, rest:r } );
				}
			}
		}
	}
	startSimulation()
	{
		var timestep = document.getElementById('timestep').value;
		if ( ! this.isSimulationRunning() ) this.timer = setInterval( function(){ massSpring.simTimeStep(); }, timestep );
	}
	stopSimulation(){clearInterval( this.timer );this.timer = undefined;}
	isSimulationRunning() { return this.timer !== undefined; }
	restartSimulation() { if ( this.isSimulationRunning() ) { this.stopSimulation(); this.startSimulation(); } }	
	toggleSimulation( btn )
	{
		if ( this.isSimulationRunning() ) {
			this.stopSimulation();
			btn.value = "Start Simulation";
		} else {
			this.startSimulation();
			btn.value = "Stop Simulation";
		}
	}	
	mouseMove()
	{
		var m = MousePos();
		this.selVert = undefined;
		var selPt;
		var minDist = 10;
		for ( var i=0; i<this.pos.length; ++i ) {
			var p = this.pos[i];
			var pv = p.trans(MVP);
			var px = pv.x / pv.w;
			var py = pv.y / pv.w;
			var dx = m.x - px;
			var dy = m.y - py;
			var len2 = dx*dx + dy*dy;
			if ( len2 < 0.001 && len2 < minDist ) {
				minDist = len2;
				this.selVert = i;
				selPt = p;
			}
		}
		if ( pointDrawer.setPoint( selPt ) ) {
			DrawScene();
			canvas.className = selPt ? "sel" : "";
		}
	}	
	mouseDown()
	{
		if ( this.selVert === undefined ) return false;
		var mInv = MatrixInverse(MVP);
		var p = this.pos[ this.selVert ];
		var pv = p.trans(MVP);
		this.holdVert = this.pos[ this.selVert ];
		
		function mouse4D()
		{
			var m = MousePos();
			return {
				x: m.x * pv.w,
				y: m.y * pv.w,
				z: pv.z,
				w: pv.w
			};
		}
		
		function invTrans(v)
		{
			return {
				x: mInv[0]*v.x + mInv[4]*v.y + mInv[ 8]*v.z + mInv[12]*v.w,
				y: mInv[1]*v.x + mInv[5]*v.y + mInv[ 9]*v.z + mInv[13]*v.w,
				z: mInv[2]*v.x + mInv[6]*v.y + mInv[10]*v.z + mInv[14]*v.w,
				w: mInv[3]*v.x + mInv[7]*v.y + mInv[11]*v.z + mInv[15]*v.w
			};
		}
		
		function mouse3D() { 
			var m = invTrans(mouse4D());
			return new Vec3( m.x/m.w, m.y/m.w, m.z/m.w );
		}
		
		var m0 = mouse3D();
		var ms = this;
		
		canvas.onmousemove = function() {
			var m1 = mouse3D();
			var d = m1.sub(m0);
			m0 = { ...m1 };
			p.inc(d);
			ms.updateMesh();
		}
		return true;		
	}	
	mouseUp()
	{
		this.holdVert = undefined;
	}

}

</script>

<script id="UI_FX" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below are the main UI control functions.
///////////////////////////////////////////////////////////////////////////////////
var showBox; 
var showMesh;
var showRope;

window.onload = function() {
	//init bool Checkboxs from the Sidemenu
	showBox = document.getElementById('show-box');
	showMesh = document.getElementById('show-mesh');
	showRope = document.getElementById('show-rope');	
	InitWebGL();
	lightView = new LightView();
	canvas.zoom = function( s ) {
		transZ *= s/canvas.height + 1;
		UpdateViewMatrices();
		DrawScene();
	}
	canvas.onwheel = function() { canvas.zoom(0.3*event.deltaY); }
	canvas.onmousedown = function() {
		if ( pendolum.mouseDown() ) {
			canvas.ondblclick = null;
			return;
		}
		canvas.ondblclick = canvas.resetView;
		var cx = event.clientX;
		var cy = event.clientY;
		if ( event.ctrlKey ) {
			canvas.onmousemove = function() {
				canvas.zoom(5*(event.clientY - cy));
				cy = event.clientY;
			}
		} else if ( event.altKey ) {
			canvas.onmousemove = function() {
				let s = 1.5*transZ*(event.clientY - cy);
				transY -= s/canvas.height;
				UpdateViewMatrices();
				DrawScene();
				cy = event.clientY;
			}
		} else {
			canvas.onmousemove = function() {
				rotY += (cx - event.clientX)/canvas.width*5;
				rotX += (cy - event.clientY)/canvas.height*5;
				cx = event.clientX;
				cy = event.clientY;
				UpdateViewMatrices();
				DrawScene();
			}
		}
	}
	canvas.onmouseup = canvas.onmouseleave = function() {
		pendolum.mouseUp();
		canvas.onmousemove = function() { pendolum.mouseMove(); }
	}
	canvas.onmousemove = function() { pendolum.mouseMove(); }
	canvas.resetView = function() {
		rotX = 0;
		rotY = 0;
		transY = 0;
		transZ = 3;
		UpdateViewMatrices();
		DrawScene();
	}
	
	//massSpring = new MassSpring();		
	nSpheres = 5;
	pendolum = new Pendolum();
	
	console.log("Pendolum",pendolum);

	SetGravity  ( document.getElementById('gravity') );	
	SetShininess( document.getElementById('shininess-exp') );
	SetDamping  ( document.getElementById('damping') );
	SetStiffness( document.getElementById('stiffness') );
	SetFreeRest ( document.getElementById('free-rest') );	

	DrawScene();
};

function WindowResize()
{
	UpdateCanvasSize();
	DrawScene();
}

function MousePos()
{
	return {
		x:  ( event.clientX / canvas.clientWidth  ) * 2 - 1,
		y: -( event.clientY / canvas.clientHeight ) * 2 + 1
	};
}

function ShowTexture( param )
{
	meshDrawers.forEach((drawer) => drawer.showTexture( param.checked ));
	//meshDrawer.showTexture( param.checked );
	DrawScene();
}

function LoadObj( param )
{
	if ( param.files && param.files[0] ) {
		var reader = new FileReader();
		reader.onload = function(e) {			
			// save for sim changes, then load it
			pendolum.loadedMesh = e.target.result;
			pendolum.setMesh( e.target.result );				
			//massSpring.setMesh( e.target.result );
		}
		reader.readAsText( param.files[0] );
	}
}

function LoadTexture( param )
{
	if ( param.files && param.files[0] ) {
		var reader = new FileReader();
		reader.onload = function(e) {
			var img = document.getElementById('texture-img');
			img.onload = function() {
				meshDrawers.forEach((drawer) => drawer.setTexture( img ));
				//meshDrawer.setTexture( img );
				DrawScene();
			}
			img.src = e.target.result;
		};
		reader.readAsDataURL( param.files[0] );
	}
}

function SetTimeStepSize( param )
{
	var s = param.value;
	document.getElementById('timestep-value').innerText = s + " ms";
}

function SetGravity( param )
{
	var v = param.value;
	var s = v / 20;
	document.getElementById('gravity-value').innerText = s.toFixed( 2 );
	pendolum.gravity.y = -s;	
	//massSpring.gravity.y = -s;
}

function SetDamping( param )
{
	var v = param.value;
	var s = v / 20;
	document.getElementById('damping-value').innerText = s.toFixed( 2 );
	//massSpring.damping = s;
	pendolum.damping = s;	
}

function SetStiffness( param )
{	
	var v = param.value;
	var s = v / 20;
	document.getElementById('stiffness-value').innerText = s.toFixed( 2 );
	//massSpring.stiffness = s;
	pendolum.stiffness = s;	
}

function SetFreeRest( param )
{	
	pendolum.freeRest = param.checked;
}

function SetShininess( param )
{
	var exp = param.value;
	var s = Math.pow(10,exp/25);
	document.getElementById('shininess-value').innerText = s.toFixed( s < 10 ? 2 : 0 );
	for(var i=0; i<nSpheres; i++)
		meshDrawers[i].setShininess(s);
	//meshDrawer.setShininess(s);
	DrawScene();
}

///////////////////////////////////////////////////////////////////////////////////
</script>

<script id="box.obj" type="text/obj">
v  -1  1 -1
v  -1 -1 -1
v   1 -1 -1
v   1  1 -1
v   1 -1  1
v  -1 -1  1
v  -1  1  1
v   1  1  1
vn  0  0  1
vn  0  0  1
vn  0  0  1
vn  0  0  1
vn  0  0 -1
vn  0  0 -1
vn  0  0 -1
vn  0  0 -1
vn  0  1  0
vn  0  1  0
vn  0  1  0
vn  0  1  0
vn -1  0  0
vn -1  0  0
vn -1  0  0
vn -1  0  0
vn  0 -1  0
vn  0 -1  0
vn  0 -1  0
vn  0 -1  0
vn  1  0  0
vn  1  0  0
vn  1  0  0
vn  1  0  0
vt 0 0
vt 0 1
vt 1 1
vt 1 0
f 1/1/1  4/4/4  3/3/3  2/2/2  
f 5/1/5  8/4/8  7/3/7  6/2/6  
f 3/1/9  5/4/12 6/3/11 2/2/10 
f 4/1/13 8/4/16 5/3/15 3/2/14 
f 1/1/17 7/4/20 8/3/19 4/2/18 
f 2/1/21 6/4/24 7/3/23 1/2/22 
</script>

<style>
html {
	color: white;
	background-color: black;
	font-family: Arial;
	overflow: hidden;
}
body {
	padding: 0;
	margin: 0;
}
input[type=checkbox], label {
	cursor: hand;
}
input[type=range] {
	width: 100%;
}
input[type=button] {
	width: 100%;
	min-width: 9em;
}
#canvas {
	display: block;
	position: absolute;
	top:  0;
	left: 0;
	width:  100%;
	height: 100%;
}
#canvas-div {
	position: relative;
}
.sel {
	cursor: hand;
}
#controls-div {
	vertical-align: top;
	background-color: #333;
	overflow: auto;
}
#controls {
	padding: 1em;
}
.control-group {
	position: relative;
	max-width: 12em;
}
.control {
	padding: 0.2em;
}
.control-x {
	display: none;
}
#lightcontrol {
	width:  12em;
	height: 12em;
	background-color: black;
	outline: 1px solid white;
	outline-offset: -1px;
}
#lightcontrol-label {
	position: absolute;
	top: 0.2em;
	left: 0.2em;
	pointer-events: none;
}
#shininess-label {
	float: left;
}
.value {
	float: right;
	text-align: right;
	width: 4em;
}
@media (orientation: landscape) {
	#canvas-div {
		display: inline-block;
		width:  calc(100% - 14em);
		height: 100%;
	}
	#controls-div {
		display: inline-block;
		width:   14em;
		height: 100%;
	}
	.control-group {
		overflow: hidden;
	}
	.control-group ~ .control-group {
		margin-top: 1em;
	}
	#texture-img {
		width: 100%;
		height: auto;
	}
}
@media (orientation: portrait) {
	#canvas-div {
		width:  100%;
		height: calc(100% - 20em);
	}
	#controls-div {
		width:  100%;
		height: 20em;
	}
	.control-group {
		display: inline-block;
		vertical-align: top;
	}
	.control-group ~ .control-group {
		margin-left: 2em;
	}
	#texture-img {
		width: auto;
		height: 5em;
	}
}
</style>

</head>
<body onresize="WindowResize()">
<div id="canvas-div"><canvas id="canvas"></canvas></div><div id="controls-div">
<div id="controls">
<div class="control-group"><canvas id="lightcontrol"></canvas><div id="lightcontrol-label">Light Direction</div></div>
<div class="control-group">
<label for="sim-select" style="font-size: 15px;" >Select Simulation:</label>
<select id="sim-select" onchange="pendolum.setSimulation(this)" style="float: right;">
	<option value="1">1 Ball</option>
	<option value="2">2 Balls</option>
	<option value="3">3 Balls</option>	
</select>
</div>
<div class="control"><input type="button" value="Start Simulation" onclick="pendolum.toggleSimulation(this)"></div>
<div class="control"><input type="button" value="Reset" onclick="pendolum.reset();pendolum.initPendolumRest();DrawScene()"></div>
<div class="control"><span id="timestep-label">Time Step Size:</span><span class="value" id="timestep-value">20 ms</span><input id="timestep" type="range" min="1" max="100" value="20" oninput="SetTimeStepSize(this)" onchange="pendolum.restartSimulation()" ondblclick="this.value=20;this.oninput();this.onchange()"/></div>
<div class="control"><span id="gravity-label">Gravity:</span><span class="value" id="gravity-value">1</span><input id="gravity" type="range" min="0" max="100" value="20" oninput="SetGravity(this)" ondblclick="this.value=20;this.oninput()"/></div>
<div class="control"><span id="damping-label">Damping:</span><span class="value" id="damping-value">5</span><input id="damping" type="range" min="0" max="100" value="100" oninput="SetDamping(this)" ondblclick="this.value=20;this.oninput()"/></div>
<div class="control"><span id="stiffness-label">Stiffness:</span><span class="value" id="stiffness-value">5</span><input id="stiffness" type="range" min="0" max="100" value="100" oninput="SetStiffness(this)" ondblclick="this.value=20;this.oninput()"/></div>

</div>
<div class="control-group">			
	<div class="control"> 
		<input id="free-rest" name="free-rest" type="checkbox" onchange="SetFreeRest(this)" />
		<label for="free-rest">mod Rope Length</label>				
		<br/>
		Show:<br/>
		<input id="show-box" name="show-box" type="checkbox" onchange="DrawScene()" checked />
		<label for="show-box"> Box</label>
		<input id="show-mesh" name="show-mesh" type="checkbox" onchange="DrawScene()" checked />
		<label for="show-mesh"> Mesh</label>
		<br/>
		<input id="show-rope" name="show-rope" type="checkbox" onchange="DrawScene()" checked />
		<label for="show-rope"> Rope</label>
		<input id="show-texture" name="show-texture" type="checkbox" onchange="ShowTexture(this)" checked />
		<label for="show-texture"> Texture</label>				
		<br/>		
	</div>
<div class="control"><span id="shininess-label">Shininess:</span><span class="value" id="shininess-value">1</span><input id="shininess-exp" type="range" min="0" max="100" value="50" oninput="SetShininess(this)" ondblclick="this.value=50;this.oninput()"/></div>
<div class="control">OBJ model:<br/><input id="obj" type="file" onchange="LoadObj(this)" accept=".obj"/></div>
<div class="control">Texture image:<br/><input id="texture" type="file" onchange="LoadTexture(this)" accept="image/*"/></div>
<div class="control"><img id="texture-img" /></div>
</div>
</div>
</div>
</body>
</html>