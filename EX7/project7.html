<doctype html>
<html>
<head>
<title>Pendolum Sim & RayTracing</title>

<script id="OBJ_Loader" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// .OBJ File Loader and parser
///////////////////////////////////////////////////////////////////////////////////

class ObjMesh
{
	constructor()
	{
		this.vpos = [];	// vertex positions
		this.face = [];	// face vertex indices
		this.tpos = [];	// texture coordinates
		this.tfac = [];	// face texture coordinate indices
		this.norm = [];	// surface normals
		this.nfac = [];	// face surface normal indices
	}
	
	// Reads the obj file at the given URL and parses it.
	load( url )
	{
		var xhttp = new XMLHttpRequest();
		xhttp.onreadystatechange = function() {
			if (this.readyState == 4 && this.status == 200) {
				parse( this.responseText );
			}
		};
		xhttp.open("GET", url, true);
		xhttp.send();
	}
	
	// Parses the contents of an obj file.
	parse( objdata )
	{
		var lines = objdata.split('\n');
		for ( var i=0; i<lines.length; ++i ) {
			var line = lines[i].trim();
			var elem = line.split(/\s+/);
			switch ( elem[0][0] ) {
				case 'v':
					switch ( elem[0].length ) {
						case 1:
							this.vpos.push( [ parseFloat(elem[1]), parseFloat(elem[2]), parseFloat(elem[3]) ] );
							break;
						case 2:
							switch ( elem[0][1] ) {
								case 't':
									this.tpos.push( [ parseFloat(elem[1]), parseFloat(elem[2]) ] );
									break;
								case 'n':
									this.norm.push( [ parseFloat(elem[1]), parseFloat(elem[2]), parseFloat(elem[3]) ] );
									break;
							}
							break;
					}
					break;
				case 'f':
					var f=[], tf=[], nf=[];
					for ( var j=1; j<elem.length; ++j ) {
						var ids = elem[j].split('/');
						var vid = parseInt(ids[0]);
						if ( vid < 0 ) vid = this.vpos.length + vid + 1;
						f.push( vid - 1 );
						if ( ids.length > 1 && ids[1] !== "" ) {
							var tid = parseInt(ids[1]);
							if ( tid < 0 ) tid = this.tpos.length + tid + 1;
							tf.push( tid - 1 );
						}
						if ( ids.length > 2 && ids[2] !== "" ) {
							var nid = parseInt(ids[2]);
							if ( nid < 0 ) nid = this.norm.length + nid + 1;
							nf.push( nid - 1 );
						}
					}
					this.face.push(f);
					if ( tf.length ) this.tfac.push(tf);
					if ( nf.length ) this.nfac.push(nf);
					break;
			}
		}
	}
	
	// Returns the bounding box of the object
	getBoundingBox()
	{
		if ( this.vpos.length == 0 ) return null;
		var min = [...this.vpos[0]];
		var max = [...this.vpos[0]];
		for ( var i=1; i<this.vpos.length; ++i ) {
			for ( var j=0; j<3; ++j ) {
				if ( min[j] > this.vpos[i][j] ) min[j] = this.vpos[i][j];
				if ( max[j] < this.vpos[i][j] ) max[j] = this.vpos[i][j];
			}
		}
		return { min: min, max: max };
	}
	
	shiftAndScale( shift, scale )
	{
		for ( var i=0; i<this.vpos.length; ++i ) {
			for ( var j=0; j<3; ++j ) {
				this.vpos[i][j] = (this.vpos[i][j] + shift[j]) * scale;
			}
		}
	}
	
	computeNormals()
	{
		function add( a, b ) {
			return [ a[0]+b[0], a[1]+b[1], a[2]+b[2] ];
		}

		function sub( a, b ) {
			return [ a[0]-b[0], a[1]-b[1], a[2]-b[2] ];
		}

		function dot( a, b ) {
			return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
		}

		function cross( a, b ) {
			return [ a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0] ];
		}
		
		function normalize( a ) {
			var len = Math.sqrt( dot(a,a) );
			return [ a[0]/len, a[1]/len, a[2]/len ];
		}
		
		if ( this.nfac.length == 0 || this.norm.length == 0 ) {
			this.nfac = this.face;
			this.norm.length = this.vpos.length;
		}
		for ( var i=0; i<this.norm.length; ++i ) this.norm[i] = [0,0,0];
		for ( var i=0; i<this.face.length; ++i ) {
			var f = this.face[i];
			var nf = this.nfac[i];
			var v0 = this.vpos[ f[0] ];
			for ( var j=1; j<f.length-1; ++j ) {
				var v1 = this.vpos[ f[j] ];
				var v2 = this.vpos[ f[j+1] ];
				var e0 = sub( v1, v0 );
				var e1 = sub( v2, v0 );
				var n  = cross( e0, e1 );
				n = normalize(n);
				this.norm[ nf[0  ] ] = add( this.norm[ nf[0  ] ], n );
				this.norm[ nf[j  ] ] = add( this.norm[ nf[j  ] ], n );
				this.norm[ nf[j+1] ] = add( this.norm[ nf[j+1] ], n );
			}
		}
		for ( var i=0; i<this.norm.length; ++i ) this.norm[i] = normalize(this.norm[i]);
	}
	
	getVertexBuffers()
	{
		function addTriangleToBuffers( mesh, fi, i, j, k )
		{
			var f  = mesh.face[fi];
			var tf = mesh.tfac[fi];
			var nf = mesh.nfac[fi];
			addTriangleToBuffer( vBuffer, mesh.vpos, f, i, j, k, addVertToBuffer3 );
			if ( tf ) {
				addTriangleToBuffer( tBuffer, mesh.tpos, tf, i, j, k, addVertToBuffer2 );
			}
			if ( nf ) {
				addTriangleToBuffer( nBuffer, mesh.norm, nf, i, j, k, addVertToBuffer3 );
			}
		}
		
		function addTriangleToBuffer( buffer, v, f, i, j, k, addVert )
		{
			addVert( buffer, v, f, i );
			addVert( buffer, v, f, j );
			addVert( buffer, v, f, k );
		}
		
		function addVertToBuffer3( buffer, v, f, i )
		{
			buffer.push( v[f[i]][0] );
			buffer.push( v[f[i]][1] );
			buffer.push( v[f[i]][2] );
		}

		function addVertToBuffer2( buffer, v, f, i )
		{
			buffer.push( v[f[i]][0] );
			buffer.push( v[f[i]][1] );
		}
	
		var vBuffer = [];
		var tBuffer = [];
		var nBuffer = [];
		
		for ( var i=0; i<this.face.length; ++i ) {
			if ( this.face[i].length < 3 ) continue;
			addTriangleToBuffers( this, i, 0, 1, 2 );
			for ( var j=3; j<this.face[i].length; ++j ) {
				addTriangleToBuffers( this, i, 0, j-1, j );
			}
		}
		
		return { positionBuffer: vBuffer, texCoordBuffer: tBuffer, normalBuffer: nBuffer };
	}

	getElementBuffers()
	{
		function setBuffer( buffer, i, data, dim )
		{
			for ( var d=0, k=i*dim; d<dim; ++d, ++k ) buffer[k] = data[d];
		}
		
		var vBuffer = [];
		var tBuffer = [];
		var nBuffer = [];
		var eBuffer = [];

		vBuffer.length = this.vpos.length * 3;
		for ( var i=0; i<this.vpos.length; ++i ) {
			setBuffer( vBuffer, i, this.vpos[i], 3 );
		}
		tBuffer.length = this.vpos.length * 2;
		nBuffer.length = this.vpos.length * 3;
		tBuffer.fill(0);
		nBuffer.fill(0);

		function addTriangleToBuffers( mesh, fi, i, j, k )
		{
			addVertexToBuffers( mesh, fi, i );
			addVertexToBuffers( mesh, fi, j );
			addVertexToBuffers( mesh, fi, k );
		}
		
		function addVertexToBuffers( mesh, fi, i )
		{
			var f  = mesh.face[fi];
			var tf = mesh.tfac[fi];
			var nf = mesh.nfac[fi];
			eBuffer.push( f[i] );
			setBuffer( tBuffer, f[i], mesh.tpos[ tf[i] ], 2 );
			setBuffer( nBuffer, f[i], mesh.norm[ nf[i] ], 3 );
		}

		for ( var i=0; i<this.face.length; ++i ) {
			if ( this.face[i].length < 3 ) continue;
			addTriangleToBuffers( this, i, 0, 1, 2 );
			for ( var j=3; j<this.face[i].length; ++j ) {
				addTriangleToBuffers( this, i, 0, j-1, j );
			}
		}

		return { elementBuffer: eBuffer, positionBuffer: vBuffer, texCoordBuffer: tBuffer, normalBuffer: nBuffer };
	}
}

</script>

<script id="Rope_Drawer" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Rope Drawer, draws line from the cealing to the pendulum
///////////////////////////////////////////////////////////////////////////////////

class RopeDrawer {
    constructor(fix, free)
      {
          // Compile the shader program
          this.prog = InitShaderProgram( ropeVShader, ropeFShader );
          
          // Get the ids of the uniform variables in the shaders
          this.mvp = gl.getUniformLocation( this.prog, 'mvp' );
  
          // Get the ids of the vertex attributes in the shaders
          this.vertPos = gl.getAttribLocation( this.prog, 'coordinates' );
          
          // Create the buffer objects
          this.vertexBuffer = gl.createBuffer();
  
          this.vertices = new Float32Array(
              [fix[0], fix[1], fix[2],
              free[0], free[1], free[2]]
            );
            
            

        }
        
    // update vertex free
    update(free){
        this.vertices = new Float32Array(
            [this.vertices[0], this.vertices[1], this.vertices[2],
            free[0], free[1], free[2]]
        );
    }

    // draw rope
    draw( trans ) //trans --> mvp
      {		
              gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
              gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW);
              gl.useProgram( this.prog );
              gl.uniformMatrix4fv( this.mvp, false, trans );
              gl.bindBuffer( gl.ARRAY_BUFFER, this.vertexBuffer );
              gl.vertexAttribPointer( this.vertPos, 3, gl.FLOAT, false, 0, 0 );
              gl.enableVertexAttribArray( this.vertPos );
              gl.disable(gl.DEPTH_TEST);
              gl.drawArrays( gl.LINES, 0, 2 );
              gl.enable(gl.DEPTH_TEST);
      }
  }

  var ropeVShader =
   `attribute vec3 coordinates;
   uniform mat4 mvp;
      void main() {
                  //gl_Position = vec4(coordinates, 1.0);
                  gl_Position = mvp * vec4(coordinates,1.0);
              }
                  `;
  var ropeFShader =
  `
  void main(void) {
      gl_FragColor = vec4(1,0,1,1);
              }
  
  `;

</script>

<script id="Mesh__Drawer_from_EX7" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Mesh Drawer from EX7
///////////////////////////////////////////////////////////////////////////////////
class MeshDrawer {
  constructor() {
    this.swap = false;
    this.showTex = true;
    this.loadTex = false;
    this.vertPos = [];
    this.texCoords = [];
    this.normals = [];
    this.shininess = 0;
    this.lightDir = [0.0, 0.0, 0.0];
    this.numTriangles = 0;
    this.positionBuffer = gl.createBuffer();
    this.txcBuffer = gl.createBuffer();
    this.mytex = gl.createTexture();
    this.normBuffer = gl.createBuffer();

    // MODEL/OBJECT SPACE --> VIEW/CAMERA SPACE
    // p' = MV * p
    // n' = MN * n
    // MN = (MV)^-1 (inverse-transpose of matrixMV)
    this.meshVS = `
		  attribute vec3 pos;			
		attribute vec2 txc; 	  
	  attribute vec3 norm;
  
	  uniform mat4 mvp;		    
	  uniform mat4 modelViewMx;
	  uniform mat3 normalMx;
		  uniform float swapYZ;
		
		  varying vec4 vPositions;
	  varying vec3 vNormals;
	  varying vec2 texCoord;
  
	  void main() 
		  {
			  gl_Position = mvp * vec4(swapYZ == 1.0 ? pos.xzy : pos , 1);					      
		vPositions = modelViewMx * vec4(swapYZ == 1.0 ? pos.xzy : pos, 1);
		vNormals = normalMx * (swapYZ == 1.0 ? norm.xzy : norm);
		texCoord = txc;
		  }
		  `;

    // BLINN SHADING
    // use hVector instead of rVector
    // vec3 reflectDir = reflect(-lightDir, normal);

    this.meshFS = `
		uniform sampler2D tex;  
		  precision mediump float;	    
		   
	  uniform float loadTex;
		   uniform float showTex;
  
	  uniform float shininess;
	  uniform vec3 vLightDir;
		
	  varying vec2 texCoord;
	  varying vec3 vNormals;
	  varying vec4 vPositions;
		  
	  void main()
		  {
		
		vec3 viewDir = normalize(-vPositions.xyz);
		vec3 normal = normalize(vNormals);
		vec3 lightDir = normalize(vLightDir);
		vec3 halfDir = normalize(lightDir + viewDir);       
		
		vec3 lightIntensity = vec3(1.0, 1.0, 1.0);      
		vec3 ambient =  lightIntensity * vec3(0.1, 0.1, 0.1);
		vec3 Kd = vec3(1.0, 1.0, 1.0);
		vec3 Ks = vec3(1.0, 1.0, 1.0);
		
  
		if( loadTex == 1.0 && showTex == 1.0){
		  Kd = texture2D(tex, texCoord).xyz;  
		  ambient = lightIntensity * Kd * 0.1;
		}    
		
		float phiCos = max(0.0, dot(normal, halfDir));
		float thetaCos = max(0.0, dot(normal, lightDir));
			  
		vec3 diffuse = thetaCos * Kd;
		vec3 specular = pow(phiCos, shininess) * Ks;    
		
		gl_FragColor = vec4(ambient + diffuse + specular, 1.0);      
	  }
		  `;

    // compile shader Program
    this.prog = InitShaderProgram(this.meshVS, this.meshFS);

    // get the location of the uniform variable
    this.mvp = gl.getUniformLocation(this.prog, "mvp");
    this.vrtxPos = gl.getAttribLocation(this.prog, "pos");
    this.texture = gl.getUniformLocation(this.prog, "tex");
    this.txcPos = gl.getAttribLocation(this.prog, "txc");
    this.swapPos = gl.getUniformLocation(this.prog, "swapYZ");
    this.loadTexPos = gl.getUniformLocation(this.prog, "loadTex");
    this.showTexPos = gl.getUniformLocation(this.prog, "showTex");
    // shader positions
    this.normPos = gl.getAttribLocation(this.prog, "norm");
    this.shininessPos = gl.getUniformLocation(this.prog, "shininess");
    this.lightDirPos = gl.getUniformLocation(this.prog, "vLightDir");
    this.mvMx = gl.getUniformLocation(this.prog, "modelViewMx");
    this.normMx = gl.getUniformLocation(this.prog, "normalMx");
  }

  setMesh(vertPos, texCoords, normals) {
    this.numTriangles = vertPos.length / 3;
    this.vertPos = vertPos;
    this.texCoords = texCoords;
    this.normals = normals;
    // allocate data on GPU memory
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(this.vertPos),
      gl.STATIC_DRAW
    );
    gl.bindBuffer(gl.ARRAY_BUFFER, this.txcBuffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(this.texCoords),
      gl.STATIC_DRAW
    );
    gl.bindBuffer(gl.ARRAY_BUFFER, this.normBuffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new Float32Array(this.normals),
      gl.STATIC_DRAW
    );
  }

  draw(matrixMVP, matrixMV, matrixNormal) {
    // clear the canvas
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(this.prog);
    // set Uniforms
    gl.uniformMatrix4fv(this.mvp, false, matrixMVP);
    gl.uniformMatrix4fv(this.mvMx, false, matrixMV);
    gl.uniformMatrix3fv(this.normMx, false, matrixNormal);
    gl.uniform1f(this.swapPos, this.swap ? 1.0 : 0.0);
    gl.uniform1f(this.loadTexPos, this.loadTex ? 1.0 : 0.0);
    gl.uniform1f(this.showTexPos, this.showTex ? 1.0 : 0.0);
    gl.uniform1f(this.shininessPos, this.shininess);
    gl.uniform3fv(this.lightDirPos, this.lightDir);
    // send texture to shader
    gl.uniform1i(this.texture, 0);
    // init vrtxPos with buffer
    gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
    gl.vertexAttribPointer(this.vrtxPos, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.vrtxPos);
    // init txcPos with buffer
    gl.bindBuffer(gl.ARRAY_BUFFER, this.txcBuffer);
    gl.vertexAttribPointer(this.txcPos, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.txcPos);
    // init normPos with buffer
    gl.bindBuffer(gl.ARRAY_BUFFER, this.normBuffer);
    gl.vertexAttribPointer(this.normPos, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.normPos);
    // draw
    gl.drawArrays(gl.TRIANGLES, 0, this.numTriangles);
  }

  // If you perform shading in the camera space,
  // you do not need to transform the light direction
  setLightDir(x, y, z) {
    this.lightDir = [x, y, z];
  }

  setShininess(shininess) {
    this.shininess = shininess;
  }

  setTexture(img) {
    if (img != null) {
      this.loadTex = true;

      gl.bindTexture(gl.TEXTURE_2D, this.mytex);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);
      gl.generateMipmap(gl.TEXTURE_2D);

      // filters
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(
        gl.TEXTURE_2D,
        gl.TEXTURE_MIN_FILTER,
        gl.LINEAR_MIPMAP_LINEAR
      );

      // binding
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.mytex);
    } else this.loadTex = false;
  }

  showTexture(show) {
    this.showTex = show;
  }

  swapYZ(swap) {
    this.swap = swap;
  }
}

</script>

<script id="WhiteBox__Drawer" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Draw the white BOX
///////////////////////////////////////////////////////////////////////////////////
class BoxDrawer {
	constructor()
	{
		// Compile the shader program
		this.prog = InitShaderProgram( boxVS, boxFS );
		
		// Get the ids of the uniform variables in the shaders
		this.mvp = gl.getUniformLocation( this.prog, 'mvp' );
		
		// Get the ids of the vertex attributes in the shaders
		this.vertPos = gl.getAttribLocation( this.prog, 'pos' );
		
		// Create the buffer objects
		
		this.vertbuffer = gl.createBuffer();
		var pos = [
			-1, -1, -1,
			-1, -1,  1,
			-1,  1, -1,
			-1,  1,  1,
			 1, -1, -1,
			 1, -1,  1,
			 1,  1, -1,
			 1,  1,  1 ];
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertbuffer);
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);

		this.linebuffer = gl.createBuffer();
		var line = [
			0,1,   1,3,   3,2,   2,0,
			4,5,   5,7,   7,6,   6,4,
			0,4,   1,5,   3,7,   2,6 ];
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.linebuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(line), gl.STATIC_DRAW);
	}
	draw( trans )
	{
		// Draw the line segments
		gl.useProgram( this.prog );
		gl.uniformMatrix4fv( this.mvp, false, trans );
		gl.bindBuffer( gl.ARRAY_BUFFER, this.vertbuffer );
		gl.vertexAttribPointer( this.vertPos, 3, gl.FLOAT, false, 0, 0 );
		gl.enableVertexAttribArray( this.vertPos );
		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, this.linebuffer );
		gl.drawElements( gl.LINES, 24, gl.UNSIGNED_BYTE, 0 );
	}
}
// Vertex shader source code
var boxVS = `
	attribute vec3 pos;
	uniform mat4 mvp;
	void main()
	{
		gl_Position = mvp * vec4(pos,1);
	}
`;
// Fragment shader source code
var boxFS = `
	precision mediump float;
	void main()
	{
		gl_FragColor = vec4(1,1,1,1);
	}
`;
///////////////////////////////////////////////////////////////////////////////////
</script>

<script id="mouseOverPoint__Drawer" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Draw MouseOver Vertex in RED
///////////////////////////////////////////////////////////////////////////////////
class PointDrawer {
	constructor()
	{
		// Compile the shader program
		this.prog = InitShaderProgram( pointVS, pointFS );
		
		// Get the ids of the uniform variables in the shaders
		this.mvp = gl.getUniformLocation( this.prog, 'mvp' );

		// Get the ids of the vertex attributes in the shaders
		this.vertPos = gl.getAttribLocation( this.prog, 'pos' );
		
		// Create the buffer objects
		this.vertbuffer = gl.createBuffer();
	}
	setPoint(p)
	{
		if ( this.selVertex == p ) return false;
		this.selVertex = p;
		this.updatePoint();
		return true;
	}
	updatePoint()
	{
		if ( this.selVertex !== undefined ) {
			var pos = [ this.selVertex.x, this.selVertex.y, this.selVertex.z ];
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertbuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos), gl.STATIC_DRAW);
		}
	}
	draw( trans )
	{
		if ( this.selVertex ) {
			gl.useProgram( this.prog );
			gl.uniformMatrix4fv( this.mvp, false, trans );
			gl.bindBuffer( gl.ARRAY_BUFFER, this.vertbuffer );
			gl.vertexAttribPointer( this.vertPos, 3, gl.FLOAT, false, 0, 0 );
			gl.enableVertexAttribArray( this.vertPos );
			gl.disable(gl.DEPTH_TEST);
			gl.drawArrays( gl.POINTS, 0, 1 );
			gl.enable(gl.DEPTH_TEST);
		}
	}
}
// Vertex shader source code
var pointVS = `
	attribute vec3 pos;
	uniform mat4 mvp;
	void main()
	{
		gl_Position = mvp * vec4(pos,1);
		gl_PointSize = 10.0;
	}
`;
// Fragment shader source code
var pointFS = `
	precision mediump float;
	void main()
	{
		gl_FragColor = vec4(1,0,0,1);
	}
`;
///////////////////////////////////////////////////////////////////////////////////
</script>

<script id="viewMatricesFX" type="text/javascript">	
///////////////////////////////////////////////////////////////////////////////////
// some functions to handle the view matrices
///////////////////////////////////////////////////////////////////////////////////
function ProjectionMatrix( c, z, fov_angle=60 )
{
	var r = c.width / c.height;
	var n = (z - 1.74);
	const min_n = 0.001;
	if ( n < min_n ) n = min_n;
	var f = (z + 1.74);;
	var fov = 3.145 * fov_angle / 180;
	var s = 1 / Math.tan( fov/2 );
	return [
		s/r, 0, 0, 0,
		0, s, 0, 0,
		0, 0, (n+f)/(f-n), 1,
		0, 0, -2*n*f/(f-n), 0
	];
}

// from PROJECT_7
function GetModelViewMatrix(translationX,translationY,translationZ,rotationX,rotationY)
{
  	// first column
  	let a = Math.cos(rotationY);
  	let c = -Math.sin(rotationY);
  	// second column
  	let e = Math.sin(rotationY) * Math.sin(rotationX);
  	let f = Math.cos(rotationX);
  	let g = Math.cos(rotationY) * Math.sin(rotationX);
  	// third column
  	let i = Math.sin(rotationY) * Math.cos(rotationX);
  	let j = -Math.sin(rotationX);
  	let k = Math.cos(rotationY) * Math.cos(rotationX);

  	var mv = [
  	  a,
  	  0,
  	  c,
  	  0,
  	  e,
  	  f,
  	  g,
  	  0,
  	  i,
  	  j,
  	  k,
  	  0,
  	  translationX,
  	  translationY,
  	  translationZ,
  	  1,
  	];

  	return mv;
}

// Multiplies two matrices and returns the result A*B.
// The arguments A and B are arrays, representing column-major matrices.
function MatrixMult( A, B )
{
	var C = Array(16);
	for ( var i=0, m=0; i<4; ++i ) {
		for ( var j=0; j<4; ++j, ++m ) {
			var v = 0;
			for ( var k=0; k<4; ++k ) {
				v += A[j+4*k] * B[k+4*i];
			}
			C[m] = v;
		}
	}
	return C;
}

// Returns the inverse of the given 4x4 matrix
function MatrixInverse( m )
{
	var r = Array(16);
	
	var v_11_14__10_15 = m[11] * m[14] - m[10] * m[15];
	var v_10_15__11_14 = m[10] * m[15] - m[11] * m[14];
	var v__7_14___6_15 = m[ 7] * m[14] - m[ 6] * m[15];
	var v__6_11___7_10 = m[ 6] * m[11] - m[ 7] * m[10];

	var v__9_15__11_13 = m[ 9] * m[15] - m[11] * m[13];
	var v_11_13___9_15 = m[11] * m[13] - m[ 9] * m[15];
	var v__5_15___7_13 = m[ 5] * m[15] - m[ 7] * m[13];
	var v__7__9___5_11 = m[ 7] * m[ 9] - m[ 5] * m[11];
	
	var v_10_13___9_14 = m[10] * m[13] - m[ 9] * m[14];
	var v__9_14__10_13 = m[ 9] * m[14] - m[10] * m[13];
	var v__6_13___5_14 = m[ 6] * m[13] - m[ 5] * m[14];
	var v__5_10___6__9 = m[ 5] * m[10] - m[ 6] * m[ 9];
	
	var v_11_12___8_15 = m[11] * m[12] - m[ 8] * m[15];
	var v__8_15__11_12 = m[ 8] * m[15] - m[11] * m[12];
	var v__7_12___4_15 = m[ 7] * m[12] - m[ 4] * m[15];
	var v__4_11___7__8 = m[ 4] * m[11] - m[ 7] * m[ 8];
	
	var v__8_14__10_12 = m[ 8] * m[14] - m[10] * m[12];
	var v_10_12___8_14 = m[10] * m[12] - m[ 8] * m[14];
	var v__4_14___6_12 = m[ 4] * m[14] - m[ 6] * m[12];
	var v__6__8___4_10 = m[ 6] * m[ 8] - m[ 4] * m[10];
	
	var v__9_12___8_13 = m[ 9] * m[12] - m[ 8] * m[13];
	var v__8_13___9_12 = m[ 8] * m[13] - m[ 9] * m[12];
	var v__5_12___4_13 = m[ 5] * m[12] - m[ 4] * m[13];
	var v__4__9___5__8 = m[ 4] * m[ 9] - m[ 5] * m[ 8];

	r[ 0] = m[5] * (-v_11_14__10_15) + m[6] * (-v__9_15__11_13) + m[7] * (-v_10_13___9_14);
	r[ 1] = m[1] * (-v_10_15__11_14) + m[2] * (-v_11_13___9_15) + m[3] * (-v__9_14__10_13);
	r[ 2] = m[1] * (-v__7_14___6_15) + m[2] * (-v__5_15___7_13) + m[3] * (-v__6_13___5_14);
	r[ 3] = m[1] * (-v__6_11___7_10) + m[2] * (-v__7__9___5_11) + m[3] * (-v__5_10___6__9);
	
	r[ 4] = m[4] * ( v_11_14__10_15) + m[6] * (-v_11_12___8_15) + m[7] * (-v__8_14__10_12);
	r[ 5] = m[0] * ( v_10_15__11_14) + m[2] * (-v__8_15__11_12) + m[3] * (-v_10_12___8_14);
	r[ 6] = m[0] * ( v__7_14___6_15) + m[2] * (-v__7_12___4_15) + m[3] * (-v__4_14___6_12);
	r[ 7] = m[0] * ( v__6_11___7_10) + m[2] * (-v__4_11___7__8) + m[3] * (-v__6__8___4_10);
	
	r[ 8] = m[4] * ( v__9_15__11_13) + m[5] * ( v_11_12___8_15) + m[7] * (-v__9_12___8_13);
	r[ 9] = m[0] * ( v_11_13___9_15) + m[1] * ( v__8_15__11_12) + m[3] * (-v__8_13___9_12);
	r[10] = m[0] * ( v__5_15___7_13) + m[1] * ( v__7_12___4_15) + m[3] * (-v__5_12___4_13);
	r[11] = m[0] * ( v__7__9___5_11) + m[1] * ( v__4_11___7__8) + m[3] * (-v__4__9___5__8);

	r[12] = m[4] * ( v_10_13___9_14) + m[5] * ( v__8_14__10_12) + m[6] * ( v__9_12___8_13);
	r[13] = m[0] * ( v__9_14__10_13) + m[1] * ( v_10_12___8_14) + m[2] * ( v__8_13___9_12);
	r[14] = m[0] * ( v__6_13___5_14) + m[1] * ( v__4_14___6_12) + m[2] * ( v__5_12___4_13);
	r[15] = m[0] * ( v__5_10___6__9) + m[1] * ( v__6__8___4_10) + m[2] * ( v__4__9___5__8);

	var det = m[0]*r[0] + m[1]*r[4] + m[2]*r[8] + m[3]*r[12];
	for ( var i=0; i<16; ++i ) r[i] /= det;
	
	return r;
}

</script>

<script id="CORE_WebGL_InitFX" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below is the core WebGL initialization code.
///////////////////////////////////////////////////////////////////////////////////

// var someDrawer; // per i 2 punti + la Linea tra i 2? TODO!!
var boxDrawer;
var pointDrawer;
var meshDrawer;
var ropeDrawer; // TODO!!
var canvas, gl;
// initial camera Positions
var rotX=0, rotY=0, transY=0, transZ=3;
var MV, MVP; // view matrices

// Called once to initialize
function InitWebGL()
{
	// Initialize the WebGL canvas
	canvas = document.getElementById("canvas");
	canvas.oncontextmenu = function() {return false;};
	gl = canvas.getContext("webgl", {antialias: false, depth: true});	// Initialize the GL context
	if (!gl) {
		alert("Unable to initialize WebGL. Your browser or machine may not support it.");
		return;
	}
	
	// Initialize settings
	gl.clearColor(0,0,0,0);
	gl.enable(gl.DEPTH_TEST);
	
	// Initialize the programs and buffers for drawing
	// someDrawer = new SomeDrawer(); // TODO!!
	ropeDrawer = new RopeDrawer();
	boxDrawer   = new BoxDrawer();
	pointDrawer = new PointDrawer();
	meshDrawer  = new MeshDrawer();
	
	// Set the viewport size
	UpdateCanvasSize();
}

// Called every time the window size is changed.
function UpdateCanvasSize()
{
	canvas.style.width  = "100%";
	canvas.style.height = "100%";
	const pixelRatio = window.devicePixelRatio || 1;
	canvas.width  = pixelRatio * canvas.clientWidth;
	canvas.height = pixelRatio * canvas.clientHeight;
	const width  = (canvas.width  / pixelRatio);
	const height = (canvas.height / pixelRatio);
	canvas.style.width  = width  + 'px';
	canvas.style.height = height + 'px';
	gl.viewport( 0, 0, canvas.width, canvas.height );
	UpdateViewMatrices();
}

function UpdateViewMatrices()
{
	var perspectiveMatrix = ProjectionMatrix( canvas, transZ );
	MV  = GetModelViewMatrix( 0, transY, transZ, rotX, rotY );
	MVP = MatrixMult( perspectiveMatrix, MV );
}

// This is the main function that handled WebGL drawing
function DrawScene()
{
	// Clear the screen and the depth buffer.
	gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
	
	// Draw the curve and then the line segments that connect the control points.
	var nrmTrans = [ MV[0],MV[1],MV[2], MV[4],MV[5],MV[6], MV[8],MV[9],MV[10] ];
	// someDrawer.draw( MVP, MV, nrmTrans ); // TODO!!
	if( showMesh.checked )
		meshDrawer.draw( MVP, MV, nrmTrans );
	if ( showBox.checked ) 
		boxDrawer.draw( MVP );	
	if( showRope.checked )
		ropeDrawer.draw( MVP );
		// TODO!! ropeDrawer.draw( MVP, MV, nrmTrans );
	// TODO: what??? do i Need the PointDrawer??
	pointDrawer.draw( MVP );
}

// This is a helper function for compiling the given vertex and fragment shader source code into a program.
function InitShaderProgram( vsSource, fsSource, wgl=gl )
{
	const vs = CompileShader( wgl.VERTEX_SHADER,   vsSource, wgl );
	const fs = CompileShader( wgl.FRAGMENT_SHADER, fsSource, wgl );

	const prog = wgl.createProgram();
	wgl.attachShader(prog, vs);
	wgl.attachShader(prog, fs);
	wgl.linkProgram(prog);

	if (!wgl.getProgramParameter(prog, wgl.LINK_STATUS)) {
		alert('Unable to initialize the shader program: ' + wgl.getProgramInfoLog(prog));
		return null;
	}
	return prog;
}

// This is a helper function for compiling a shader, called by InitShaderProgram().
function CompileShader( type, source, wgl=gl )
{
	const shader = wgl.createShader(type);
	wgl.shaderSource(shader, source);
	wgl.compileShader(shader);
	if (!wgl.getShaderParameter( shader, wgl.COMPILE_STATUS) ) {
		alert('An error occurred compiling shader:\n' + wgl.getShaderInfoLog(shader));
		wgl.deleteShader(shader);
		return null;
	}
	return shader;
}

</script>

<script id="lightControlCode" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below is the light view control code
///////////////////////////////////////////////////////////////////////////////////

var lightView;

class LightView
{
	constructor()
	{
		this.canvas = document.getElementById("lightcontrol");
		this.canvas.oncontextmenu = function() {return false;};
		this.gl = this.canvas.getContext("webgl", {antialias: false, depth: true});	// Initialize the GL context
		if (!this.gl) {
			alert("Unable to initialize WebGL. Your browser or machine may not support it.");
			return;
		}
		
		// Initialize settings
		this.gl.clearColor(0.33,0.33,0.33,0);
		this.gl.enable(gl.DEPTH_TEST);
		
		this.rotX = 0;
		this.rotY = 0;
		this.posZ = 5;
		
		this.resCircle = 32;
		this.resArrow = 16;
		this.buffer = this.gl.createBuffer();
		var data = [];
		for ( var i=0; i<=this.resCircle; ++i ) {
			var a = 2 * Math.PI * i / this.resCircle;
			var x = Math.cos(a);
			var y = Math.sin(a);
			data.push( x * .9 );
			data.push( y * .9 );
			data.push( 0 );
			data.push( x );
			data.push( y );
			data.push( 0 );
		}
		for ( var i=0; i<=this.resCircle; ++i ) {
			var a = 2 * Math.PI * i / this.resCircle;
			var x = Math.cos(a);
			var y = Math.sin(a);
			data.push( x );
			data.push( y );
			data.push( -.05 );
			data.push( x );
			data.push( y );
			data.push( 0.05 );
		}
		for ( var i=0; i<=this.resArrow; ++i ) {
			var a = 2 * Math.PI * i / this.resArrow;
			var x = Math.cos(a) * .07;
			var y = Math.sin(a) * .07;
			data.push( x );
			data.push( y );
			data.push( -1 );
			data.push( x );
			data.push( y );
			data.push( 0 );
		}
		data.push( 0 );
		data.push( 0 );
		data.push( -1.2 );
		for ( var i=0; i<=this.resArrow; ++i ) {
			var a = 2 * Math.PI * i / this.resArrow;
			var x = Math.cos(a) * .15;
			var y = Math.sin(a) * .15;
			data.push( x );
			data.push( y );
			data.push( -0.9 );
		}
		this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
		this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(data), this.gl.STATIC_DRAW);
		
		// Set the viewport size
		this.canvas.style.width  = "";
		this.canvas.style.height = "";
		const pixelRatio = window.devicePixelRatio || 1;
		this.canvas.width  = pixelRatio * this.canvas.clientWidth;
		this.canvas.height = pixelRatio * this.canvas.clientHeight;
		const width  = (this.canvas.width  / pixelRatio);
		const height = (this.canvas.height / pixelRatio);
		this.canvas.style.width  = width  + 'px';
		this.canvas.style.height = height + 'px';
		this.gl.viewport( 0, 0, this.canvas.width, this.canvas.height );
		this.proj = ProjectionMatrix( this.canvas, this.posZ, 30 );
		
		// Compile the shader program
		this.prog = InitShaderProgram( lightViewVS, lightViewFS, this.gl );
		this.mvp = this.gl.getUniformLocation( this.prog, 'mvp' );
		this.clr1 = this.gl.getUniformLocation( this.prog, 'clr1' );
		this.clr2 = this.gl.getUniformLocation( this.prog, 'clr2' );
		this.vertPos = this.gl.getAttribLocation( this.prog, 'pos' );
		
		this.draw();
		this.updateLightDir();
		
		this.canvas.onmousedown = function() {
			var cx = event.clientX;
			var cy = event.clientY;
			lightView.canvas.onmousemove = function() {
				lightView.rotY += (cx - event.clientX)/lightView.canvas.width*5;
				lightView.rotX += (cy - event.clientY)/lightView.canvas.height*5;
				cx = event.clientX;
				cy = event.clientY;
				lightView.draw();
				lightView.updateLightDir();
			}
		}
		this.canvas.onmouseup = this.canvas.onmouseleave = function() {
			lightView.canvas.onmousemove = null;
		}
	}
	
	updateLightDir()
	{
		var cy = Math.cos( this.rotY );
		var sy = Math.sin( this.rotY );
		var cx = Math.cos( this.rotX );
		var sx = Math.sin( this.rotX );
		meshDrawer.setLightDir( -sy, cy*sx, -cy*cx );
		DrawScene();
	}
	
	draw()
	{
		// Clear the screen and the depth buffer.
		this.gl.clear( this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT );
		
		this.gl.bindBuffer( this.gl.ARRAY_BUFFER, this.buffer );
		this.gl.vertexAttribPointer( this.vertPos, 3, this.gl.FLOAT, false, 0, 0 );
		this.gl.enableVertexAttribArray( this.buffer );

		this.gl.useProgram( this.prog );
		var mvp = MatrixMult( this.proj, [ 1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,this.posZ,1 ] );
		this.gl.uniformMatrix4fv( this.mvp, false, mvp );
		this.gl.uniform3f( this.clr1, 0.6,0.6,0.6 );
		this.gl.uniform3f( this.clr2, 0,0,0 );
		this.gl.drawArrays( this.gl.TRIANGLE_STRIP, 0, this.resCircle*2+2 );

		var mv  = GetModelViewMatrix( 0, 0, this.posZ, this.rotX, this.rotY );
		var mvp = MatrixMult( this.proj, mv );
		this.gl.uniformMatrix4fv( this.mvp, false, mvp );
		this.gl.uniform3f( this.clr1, 1,1,1 );
		this.gl.drawArrays( this.gl.TRIANGLE_STRIP, 0, this.resCircle*2+2 );
		this.gl.drawArrays( this.gl.TRIANGLE_STRIP, this.resCircle*2+2, this.resCircle*2+2 );
		this.gl.uniform3f( this.clr1, 0,0,0 );
		this.gl.uniform3f( this.clr2, 1,1,1 );
		this.gl.drawArrays( this.gl.TRIANGLE_STRIP, this.resCircle*4+4, this.resArrow*2+2 );
		this.gl.drawArrays( this.gl.TRIANGLE_FAN, this.resCircle*4+4 + this.resArrow*2+2, this.resArrow+2 );
	}
}

// Vertex shader source code
const lightViewVS = `
	attribute vec3 pos;
	uniform mat4 mvp;
	void main()
	{
		gl_Position = mvp * vec4(pos,1);
	}
`;
// Fragment shader source code
var lightViewFS = `
	precision mediump float;
	uniform vec3 clr1;
	uniform vec3 clr2;
	void main()
	{
		gl_FragColor = gl_FrontFacing ? vec4(clr1,1) : vec4(clr2,1);
	}
`;
///////////////////////////////////////////////////////////////////////////////////
</script>

<script id="MASS_SPRING_SIM" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below is the mass-spring system code
///////////////////////////////////////////////////////////////////////////////////

var massSpring; // TODO!! cosa salva questo??

class Vec3 {
	constructor( x, y, z ) { this.init(x,y,z); }
	init( x, y, z ) { this.x=x; this.y=y; this.z=z; }
	copy ( ) { return new Vec3( this.x, this.y, this.z ); }
	set  (v) { this.x =v.x; this.y =v.y; this.z =v.z; }
	inc  (v) { this.x+=v.x; this.y+=v.y; this.z+=v.z; }
	dec  (v) { this.x-=v.x; this.y-=v.y; this.z-=v.z; }
	scale(f) { this.x*=f; this.y*=f; this.z*=f; }
	add  (v) { return new Vec3( this.x+v.x, this.y+v.y, this.z+v.z ); }
	sub  (v) { return new Vec3( this.x-v.x, this.y-v.y, this.z-v.z ); }
	dot  (v) { return this.x*v.x + this.y*v.y + this.z*v.z; }
	cross(v) { return new Vec3( this.y*v.z-this.z*v.y, this.z*v.x-this.x*v.z, this.x*v.y-this.y*v.x ); }
	mul  (f) { return new Vec3( this.x*f, this.y*f, this.z*f ); }
	div  (f) { return new Vec3( this.x/f, this.y/f, this.z/f ); }
	len2 ( ) { return this.dot(this); }
	len  ( ) { return Math.sqrt(this.len2()); }
	unit ( ) { return this.div(this.len()); }
	normalize() {
		var l = this.len();
		this.x /= l;
		this.y /= l;
		this.z /= l;
	}
	trans(m) {
		return {
			x: m[0]*this.x + m[4]*this.y + m[ 8]*this.z + m[12],
			y: m[1]*this.x + m[5]*this.y + m[ 9]*this.z + m[13],
			z: m[2]*this.x + m[6]*this.y + m[10]*this.z + m[14],
			w: m[3]*this.x + m[7]*this.y + m[11]*this.z + m[15]
		};
	}
}

function ToVec3(a) { return new Vec3(a[0],a[1],a[2]); }

// This function is called for every step of the simulation.
// Its job is to advance the simulation for the given time step duration dt.
// It updates the given positions and velocities.
function SimTimeStep(
  dt,
  positions,
  velocities,
  springs,
  stiffness,
  damping,
  particleMass,
  gravity,
  restitution
) {
  /*
init(x,y,z): sets the x, y, and z coordinates to the given values.
copy(): returns a copy of the vector object.
set(v): sets the x, y, and z coordinates to the same values as the given vector v.
inc(v): increments the x, y, and z coordinate values by adding the coordinate values of the given vector v.
dec(v): decrements the x, y, and z coordinate values by subtracting the coordinate values of the given vector v.
scale(f): multiplies the x, y, and z coordinates by the given scalar f.
add(v): add the given vector v to this vector and returns the resulting vector.
sub(v): subtracts the given vector v from this vector and returns the resulting vector.
dot(v): computes the dot product of this vector and the given vector v and returns the resulting scalar.
cross(v): computes the cross product of this vector and the given vector v and returns the resulting vector.
mul(f): multiplies the vector by the given scalar f and returns the result.
div(f): divides the vector by the given scalar f and returns the result.
len2(): returns the squared length of the vector.
len(): returns the length of the vector.
unit(): returns the unit vector along the direction of this vector.
normalize(): normalizes this vector, turning it into a unit vector.
*/
  var forces = [...Array(positions.length)].map(
    (_, i) => new Vec3(0, gravity.y * particleMass, 0)
  );
  // Compute the total force of each particle
  springs.forEach((spring) => {
    // spring = {p0: , p1: , rest: }
    let p0 = spring.p0;
    let p0Pos = positions[p0]; //Vec3
    let p0Vel = velocities[p0]; //Vec3
    let p1 = spring.p1;
    let p1Pos = positions[p1];
    let p1Vel = velocities[p1];
    let restLength = spring.rest; //float
    // spring Force
    let lSpring = p1Pos.sub(p0Pos).len();
    let springDir = p1Pos.sub(p0Pos).div(lSpring);
    let springForceP0 = springDir.mul(stiffness * (lSpring - restLength));
    let springForceP1 = springForceP0.mul(-1);
    // damping force
    let lDamp = p1Vel.sub(p0Vel).dot(springDir);
    let dampForceP0 = springDir.mul(damping * lDamp);
    let dampForceP1 = dampForceP0.mul(-1);
    //console.log("P0",springForceP0, dampForceP0);
    //console.log("P1",springForceP1, dampForceP1);
    // total force
    forces[p0] = forces[p0].add(springForceP0).add(dampForceP0);
    forces[p1] = forces[p1].add(springForceP1).add(dampForceP1);
  });
  // Compute Acceleration for each particle
  let acc = forces.map((f) => f.div(particleMass));
  // Update positions and velocities
  velocities.forEach((vel, i) => {
    // Semi-Implicit Euler Integration ------------------------------------------        
    vel.inc(acc[i].mul(dt));    
    positions[i].inc(vel.mul(dt));
  });  
  // Handle collisions
  positions.forEach((pos, i) => {
    if (pos.y < -1.0) {
      let h = -1.0 - pos.y;
      pos.y = -1.0 + h*restitution;      
      velocities[i] = velocities[i].mul(-restitution);
    }
    if(pos.y > 1.0){
      let h = pos.y - 1.0;
      pos.y = 1.0 - h*restitution;
      velocities[i] = velocities[i].mul(-restitution);
    }
    if(pos.x < -1.0){
      let h = -1.0 - pos.x;
      pos.x = -1.0 + h*restitution;
      velocities[i] = velocities[i].mul(-restitution);
    }
    if(pos.x > 1.0){
      let h = pos.x - 1.0;
      pos.x = 1.0 - h*restitution;
      velocities[i] = velocities[i].mul(-restitution);
    }
    if(pos.z < -1.0){
      let h = -1.0 - pos.z;
      pos.z = -1.0 + h*restitution;
      velocities[i] = velocities[i].mul(-restitution);
    }
    if(pos.z > 1.0){
      let h = pos.z - 1.0;
      pos.z = 1.0 - h*restitution;
      velocities[i] = velocities[i].mul(-restitution);
    }
  });
}


class MassSpring {

	constructor()
	{
		this.gravity = new Vec3( 0, -2.0, 0 );
		this.mass = .1;
		this.stiffness = 1;
		this.damping = 1;
		this.restitution = .8;
		this.setMesh( document.getElementById('box.obj').text );
	}
	setMesh( objdef )
	{
		this.mesh = new ObjMesh;
		this.mesh.parse( objdef );
		var box = this.mesh.getBoundingBox();
		var shift = [
			-(box.min[0]+box.max[0])/2,
			-(box.min[1]+box.max[1])/2,
			-(box.min[2]+box.max[2])/2
		];
		var size = [
			(box.max[0]-box.min[0])/2,
			(box.max[1]-box.min[1])/2,
			(box.max[2]-box.min[2])/2
		];
		var maxSize = Math.max( size[0], size[1], size[2] );
		var scale = 0.4/maxSize;
		this.mesh.shiftAndScale( shift, scale );
		this.mesh.computeNormals();
		this.reset();
		this.initSprings();
		DrawScene();
	}
	initSprings()
	{
		this.springs = [];
		for ( var i=0; i<this.pos.length; ++i ) {
			for ( var j=i+1; j<this.pos.length; ++j ) {
				var r = this.pos[i].sub(this.pos[j]).len();
				if ( r > .02 ) 
				{
					this.springs.push( { p0:i, p1:j, rest:r } );
				}
			}
		}
	}
	reset()
	{
		this.pos = Array( this.mesh.vpos.length );
		for ( var i=0; i<this.pos.length; ++i ) this.pos[i] = ToVec3( this.mesh.vpos[i] );
		this.vel = Array( this.pos.length );
		for ( var i=0; i<this.vel.length; ++i ) this.vel[i] = new Vec3(0,0,0);
		this.nrm = Array( this.mesh.norm.length );
		for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i] = ToVec3( this.mesh.norm[i] );
		this.buffers = this.mesh.getVertexBuffers();
		meshDrawer.setMesh( this.buffers.positionBuffer, this.buffers.texCoordBuffer, this.buffers.normalBuffer );
	}

	updateMesh()
	{
		function updateBuffer( buffer, faces, verts )
		{
			function addTriangleToBuffer( buffer, bi, vals, i, j, k )
			{
				buffer[bi++] = vals[i].x;
				buffer[bi++] = vals[i].y;
				buffer[bi++] = vals[i].z;
				buffer[bi++] = vals[j].x;
				buffer[bi++] = vals[j].y;
				buffer[bi++] = vals[j].z;
				buffer[bi++] = vals[k].x;
				buffer[bi++] = vals[k].y;
				buffer[bi++] = vals[k].z;
			}
			for ( var i=0, bi=0; i<faces.length; ++i ) {
				var f = faces[i];
				if ( f.length < 3 ) continue;
				addTriangleToBuffer( buffer, bi, verts, f[0], f[1], f[2] );
				bi += 9;
				for ( var j=3; j<f.length; ++j, bi+=9 ) {
					addTriangleToBuffer( buffer, bi, verts, f[0], f[j-1], f[j] );
				}
			}
		}
		
		// update the position buffer
		updateBuffer( this.buffers.positionBuffer, this.mesh.face, this.pos );
		
		// update normals
		for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i].init(0,0,0);
		for ( var i=0; i<this.mesh.face.length; ++i ) {
			var f = this.mesh.face[i];
			var nf = this.mesh.nfac[i];
			var v0 = this.pos[ f[0] ];
			for ( var j=1; j<f.length-1; ++j ) {
				var v1 = this.pos[ f[j] ];
				var v2 = this.pos[ f[j+1] ];
				var e0 = v1.sub(v0);
				var e1 = v2.sub(v0);
				var n  = e0.cross(e1);
				n = n.unit();
				this.nrm[ nf[0  ] ].inc(n);
				this.nrm[ nf[j  ] ].inc(n);
				this.nrm[ nf[j+1] ].inc(n);
			}
		}
		for ( var i=0; i<this.nrm.length; ++i ) this.nrm[i].normalize();
		updateBuffer( this.buffers.normalBuffer, this.mesh.nfac, this.nrm );

		// Update the mesh drawer and redraw scene
		meshDrawer.setMesh( this.buffers.positionBuffer, this.buffers.texCoordBuffer, this.buffers.normalBuffer );

		pointDrawer.updatePoint();
		DrawScene();
	}

	simTimeStep()
	{
		// remember the position of the selected vertex, if any
		var p = this.holdVert ? this.holdVert.copy() : undefined;

		// Update positions and velocities
		var timestep = document.getElementById('timestep').value;
		const dt = timestep / 1000;	// time step in seconds
		const damping = this.damping * this.stiffness * dt;
		// the Calling to the DeltaT for the next Iteration of the SimulationTODO!!
		SimTimeStep( dt, this.pos, this.vel, this.springs, this.stiffness, damping, this.mass, this.gravity, this.restitution );
		
		// make sure that the selected vertex does not change position
		if ( p ) {
			this.holdVert.set(p);
			this.vel[ this.selVert ].init(0,0,0);
		}
		
		this.updateMesh();
	}
	startSimulation()
	{
		var timestep = document.getElementById('timestep').value;
		if ( ! this.isSimulationRunning() ) this.timer = setInterval( function(){ massSpring.simTimeStep(); }, timestep );
	}
	stopSimulation()
	{
		clearInterval( this.timer );
		this.timer = undefined;
	}
	isSimulationRunning() { return this.timer !== undefined; }
	restartSimulation() { if ( this.isSimulationRunning() ) { this.stopSimulation(); this.startSimulation(); } }
	toggleSimulation( btn )
	{
		if ( this.isSimulationRunning() ) {
			this.stopSimulation();
			btn.value = "Start Simulation";
		} else {
			this.startSimulation();
			btn.value = "Stop Simulation";
		}
	}
	
	mouseMove()
	{
		var m = MousePos();
		this.selVert = undefined;
		var selPt;
		var minDist = 10;
		for ( var i=0; i<this.pos.length; ++i ) {
			var p = this.pos[i];
			var pv = p.trans(MVP);
			var px = pv.x / pv.w;
			var py = pv.y / pv.w;
			var dx = m.x - px;
			var dy = m.y - py;
			var len2 = dx*dx + dy*dy;
			if ( len2 < 0.001 && len2 < minDist ) {
				minDist = len2;
				this.selVert = i;
				selPt = p;
			}
		}
		if ( pointDrawer.setPoint( selPt ) ) {
			DrawScene();
			canvas.className = selPt ? "sel" : "";
		}
	}
	
	mouseDown()
	{
		if ( this.selVert === undefined ) return false;
		var mInv = MatrixInverse(MVP);
		var p = this.pos[ this.selVert ];
		var pv = p.trans(MVP);
		this.holdVert = this.pos[ this.selVert ];
		
		function mouse4D()
		{
			var m = MousePos();
			return {
				x: m.x * pv.w,
				y: m.y * pv.w,
				z: pv.z,
				w: pv.w
			};
		}
		
		function invTrans(v)
		{
			return {
				x: mInv[0]*v.x + mInv[4]*v.y + mInv[ 8]*v.z + mInv[12]*v.w,
				y: mInv[1]*v.x + mInv[5]*v.y + mInv[ 9]*v.z + mInv[13]*v.w,
				z: mInv[2]*v.x + mInv[6]*v.y + mInv[10]*v.z + mInv[14]*v.w,
				w: mInv[3]*v.x + mInv[7]*v.y + mInv[11]*v.z + mInv[15]*v.w
			};
		}
		
		function mouse3D() { 
			var m = invTrans(mouse4D());
			return new Vec3( m.x/m.w, m.y/m.w, m.z/m.w );
		}
		
		var m0 = mouse3D();
		var ms = this;
		
		canvas.onmousemove = function() {
			var m1 = mouse3D();
			var d = m1.sub(m0);
			m0 = { ...m1 };
			p.inc(d);
			ms.updateMesh();
		}
		return true;		
	}
	
	mouseUp()
	{
		this.holdVert = undefined;
	}
}

</script>

<script id="UI_FX" type="text/javascript">
///////////////////////////////////////////////////////////////////////////////////
// Below are the main UI control functions.
///////////////////////////////////////////////////////////////////////////////////

// Booleans from checkbox in the Sidemenu
var showBox; 
var showMesh;
var showRope;

window.onload = function() {
	//init Checkboxs from the Sidemenu
	showBox = document.getElementById('show-box');
	showMesh = document.getElementById('show-mesh');
	showRope = document.getElementById('show-rope');
	InitWebGL();
	lightView = new LightView();
	canvas.zoom = function( s ) {
		transZ *= s/canvas.height + 1;
		UpdateViewMatrices();
		DrawScene();
	}
	canvas.onwheel = function() { canvas.zoom(0.3*event.deltaY); }
	canvas.onmousedown = function() {
		if ( massSpring.mouseDown() ) {
			canvas.ondblclick = null;
			return;
		}
		canvas.ondblclick = canvas.resetView;
		var cx = event.clientX;
		var cy = event.clientY;
		if ( event.ctrlKey ) {
			canvas.onmousemove = function() {
				canvas.zoom(5*(event.clientY - cy));
				cy = event.clientY;
			}
		} else if ( event.altKey ) {
			canvas.onmousemove = function() {
				let s = 1.5*transZ*(event.clientY - cy);
				transY -= s/canvas.height;
				UpdateViewMatrices();
				DrawScene();
				cy = event.clientY;
			}
		} else {
			canvas.onmousemove = function() {
				rotY += (cx - event.clientX)/canvas.width*5;
				rotX += (cy - event.clientY)/canvas.height*5;
				cx = event.clientX;
				cy = event.clientY;
				UpdateViewMatrices();
				DrawScene();
			}
		}
	}
	canvas.onmouseup = canvas.onmouseleave = function() {
		massSpring.mouseUp();
		canvas.onmousemove = function() { massSpring.mouseMove(); }
	}
	canvas.onmousemove = function() { massSpring.mouseMove(); }
	canvas.resetView = function() {
		rotX = 0;
		rotY = 0;
		transY = 0;
		transZ = 3;
		UpdateViewMatrices();
		DrawScene();
	}
	
	//// someSimulation = new SomeSimulation(); TODO!!
	massSpring = new MassSpring();
	

	SetGravity  ( document.getElementById('gravity') );
	SetMass     ( document.getElementById('mass') );
	SetStiffness( document.getElementById('stiffness') );
	SetShininess( document.getElementById('shininess-exp') );

	DrawScene();
};
function WindowResize()
{
	UpdateCanvasSize();
	DrawScene();
}

function MousePos()
{
	return {
		x:  ( event.clientX / canvas.clientWidth  ) * 2 - 1,
		y: -( event.clientY / canvas.clientHeight ) * 2 + 1
	};
}

function ShowTexture( param )
{
	meshDrawer.showTexture( param.checked );
	DrawScene();
}

function LoadObj( param )
{
	if ( param.files && param.files[0] ) {
		var reader = new FileReader();
		reader.onload = function(e) {
			massSpring.setMesh( e.target.result );
		}
		reader.readAsText( param.files[0] );
	}
}

function LoadTexture( param )
{
	if ( param.files && param.files[0] ) {
		var reader = new FileReader();
		reader.onload = function(e) {
			var img = document.getElementById('texture-img');
			img.onload = function() {
				meshDrawer.setTexture( img );
				DrawScene();
			}
			img.src = e.target.result;
		};
		reader.readAsDataURL( param.files[0] );
	}
}

function SetTimeStepSize( param )
{
	var s = param.value;
	document.getElementById('timestep-value').innerText = s + " ms";
}

function SetGravity( param )
{
	var v = param.value;
	var s = v / 20;
	document.getElementById('gravity-value').innerText = s.toFixed( 2 );
	massSpring.gravity.y = -s;
}

function SetMass( param )
{
	var v = param.value;
	var s = v / 200;
	document.getElementById('mass-value').innerText = s.toFixed( 3 );
	massSpring.mass = s;
}

function SetStiffness( param )
{
	var v = param.value;
	var s = v / 20;
	document.getElementById('stiffness-value').innerText = s.toFixed( 2 );
	massSpring.stiffness = s;
}

function SetDamping( param )
{
	var v = param.value;
	var s = v / 20;
	document.getElementById('damping-value').innerText = s.toFixed( 2 );
	massSpring.damping = s;
}

function SetShininess( param )
{
	var exp = param.value;
	var s = Math.pow(10,exp/25);
	document.getElementById('shininess-value').innerText = s.toFixed( s < 10 ? 2 : 0 );
	meshDrawer.setShininess(s);
	DrawScene();
}

///////////////////////////////////////////////////////////////////////////////////
</script>

<script id="box.obj" type="text/obj">
v  -1  1 -1
v  -1 -1 -1
v   1 -1 -1
v   1  1 -1
v   1 -1  1
v  -1 -1  1
v  -1  1  1
v   1  1  1
vn  0  0  1
vn  0  0  1
vn  0  0  1
vn  0  0  1
vn  0  0 -1
vn  0  0 -1
vn  0  0 -1
vn  0  0 -1
vn  0  1  0
vn  0  1  0
vn  0  1  0
vn  0  1  0
vn -1  0  0
vn -1  0  0
vn -1  0  0
vn -1  0  0
vn  0 -1  0
vn  0 -1  0
vn  0 -1  0
vn  0 -1  0
vn  1  0  0
vn  1  0  0
vn  1  0  0
vn  1  0  0
vt 0 0
vt 0 1
vt 1 1
vt 1 0
f 1/1/1  4/4/4  3/3/3  2/2/2  
f 5/1/5  8/4/8  7/3/7  6/2/6  
f 3/1/9  5/4/12 6/3/11 2/2/10 
f 4/1/13 8/4/16 5/3/15 3/2/14 
f 1/1/17 7/4/20 8/3/19 4/2/18 
f 2/1/21 6/4/24 7/3/23 1/2/22 
</script>

<style>
html {
	color: white;
	background-color: black;
	font-family: Arial;
	overflow: hidden;
}
body {
	padding: 0;
	margin: 0;
}
input[type=checkbox], label {
	cursor: hand;
}
input[type=range] {
	width: 100%;
}
input[type=button] {
	width: 100%;
	min-width: 9em;
}
#canvas {
	display: block;
	position: absolute;
	top:  0;
	left: 0;
	width:  100%;
	height: 100%;
}
#canvas-div {
	position: relative;
}
.sel {
	cursor: hand;
}
#controls-div {
	vertical-align: top;
	background-color: #333;
	overflow: auto;
}
#controls {
	padding: 1em;
}
.control-group {
	position: relative;
	max-width: 12em;
}
.control {
	padding: 0.2em;
}
.control-x {
	display: none;
}
#lightcontrol {
	width:  12em;
	height: 12em;
	background-color: black;
	outline: 1px solid white;
	outline-offset: -1px;
}
#lightcontrol-label {
	position: absolute;
	top: 0.2em;
	left: 0.2em;
	pointer-events: none;
}
#shininess-label {
	float: left;
}
.value {
	float: right;
	text-align: right;
	width: 4em;
}
@media (orientation: landscape) {
	#canvas-div {
		display: inline-block;
		width:  calc(100% - 14em);
		height: 100%;
	}
	#controls-div {
		display: inline-block;
		width:   14em;
		height: 100%;
	}
	.control-group {
		overflow: hidden;
	}
	.control-group ~ .control-group {
		margin-top: 1em;
	}
	#texture-img {
		width: 100%;
		height: auto;
	}
}
@media (orientation: portrait) {
	#canvas-div {
		width:  100%;
		height: calc(100% - 20em);
	}
	#controls-div {
		width:  100%;
		height: 20em;
	}
	.control-group {
		display: inline-block;
		vertical-align: top;
	}
	.control-group ~ .control-group {
		margin-left: 2em;
	}
	#texture-img {
		width: auto;
		height: 5em;
	}
}
</style>

</head>
<body onresize="WindowResize()">
<div id="canvas-div"><canvas id="canvas"></canvas></div><div id="controls-div">
<div id="controls">
<div class="control-group"><canvas id="lightcontrol"></canvas><div id="lightcontrol-label">Light Direction</div></div>
<div class="control-group">
<div class="control"><input type="button" value="Start Simulation" onclick="SomeSimulationClass.toggleSimulation(this)"></div>
<div class="control"><input type="button" value="Reset" onclick="SomeSimulationClass.resetSimulation();DrawScene()"></div>
<div class="control"><span id="timestep-label">Time Step Size:</span><span class="value" id="timestep-value">20 ms</span><input id="timestep" type="range" min="1" max="100" value="20" oninput="SetTimeStepSize(this)" onchange="SomeSimulationClass.restartSimulation()" ondblclick="this.value=20;this.oninput();this.onchange()"/></div>
<div class="control"><span id="gravity-label">Gravity:</span><span class="value" id="gravity-value">1</span><input id="gravity" type="range" min="0" max="100" value="20" oninput="SetGravity(this)" ondblclick="this.value=20;this.oninput()"/></div>
<div class="control"><span id="mass-label">Mass:</span><span class="value" id="mass-value">1</span><input id="mass" type="range" min="1" max="100" value="20" oninput="SetMass(this)" ondblclick="this.value=20;this.oninput()"/></div>
<div class="control"><span id="stiffness-label">Stiffness:</span><span class="value" id="stiffness-value">1</span><input id="stiffness" type="range" min="0" max="100" value="20" oninput="SetStiffness(this)" ondblclick="this.value=20;this.oninput()"/></div>
<div class="control"><span id="damping-label">Damping:</span><span class="value" id="damping-value">1.00</span><input id="damping" type="range" min="0" max="100" value="20" oninput="SetDamping(this)" ondblclick="this.value=20;this.oninput()"/></div>
</div>
<div class="control-group">
	Show:<br/>
	<div class="control">
		<input id="show-box" name="show-box" type="checkbox" onchange="DrawScene()" checked />
		<label for="show-box"> Box</label>
		<input id="show-mesh" name="show-mesh" type="checkbox" onchange="DrawScene()" checked />
		<label for="show-mesh"> Mesh</label>
		<br/>
		<input id="show-rope" name="show-rope" type="checkbox" onchange="DrawScene()" checked />
		<label for="show-rope"> Rope</label>
		<input id="show-texture" name="show-texture" type="checkbox" onchange="ShowTexture(this)" checked />
		<label for="show-texture"> Texture</label>
	</div>
<div class="control"><span id="shininess-label">Shininess:</span><span class="value" id="shininess-value">1</span><input id="shininess-exp" type="range" min="0" max="100" value="50" oninput="SetShininess(this)" ondblclick="this.value=50;this.oninput()"/></div>
<div class="control">OBJ model:<br/><input id="obj" type="file" onchange="LoadObj(this)" accept=".obj"/></div>
<div class="control">Texture image:<br/><input id="texture" type="file" onchange="LoadTexture(this)" accept="image/*"/></div>
<div class="control"><img id="texture-img" /></div>
</div>
</div>
</div>
</body>
</html>