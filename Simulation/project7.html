<doctype html>
<!-- Copyright 2020, Cem Yuksel, University of Utah -->
<html>
<head>
<title>Pendolum Project</title>
<link rel="stylesheet" type="text/css" href="style.css">


<script type="text/javascript" src="lightView.js">
	var lightView;
	</script>
<script type="text/javascript" src="objLoader.js"></script>
<script type="text/javascript" src="meshDrawer.js"></script>
<script type="text/javascript" src="boxDrawer.js"></script>
<script type="text/javascript" src="ropeDrawer.js"></script>
<script type="text/javascript" src="pointDrawer.js"></script>
<script type="text/obj" id="box.obj">
v  -1  1 -1
v  -1 -1 -1
v   1 -1 -1
v   1  1 -1
v   1 -1  1
v  -1 -1  1
v  -1  1  1
v   1  1  1
vn  0  0  1
vn  0  0  1
vn  0  0  1
vn  0  0  1
vn  0  0 -1
vn  0  0 -1
vn  0  0 -1
vn  0  0 -1
vn  0  1  0
vn  0  1  0
vn  0  1  0
vn  0  1  0
vn -1  0  0
vn -1  0  0
vn -1  0  0
vn -1  0  0
vn  0 -1  0
vn  0 -1  0
vn  0 -1  0
vn  0 -1  0
vn  1  0  0
vn  1  0  0
vn  1  0  0
vn  1  0  0
vt 0 0
vt 0 1
vt 1 1
vt 1 0
f 1/1/1  4/4/4  3/3/3  2/2/2  
f 5/1/5  8/4/8  7/3/7  6/2/6  
f 3/1/9  5/4/12 6/3/11 2/2/10 
f 4/1/13 8/4/16 5/3/15 3/2/14 
f 1/1/17 7/4/20 8/3/19 4/2/18 
f 2/1/21 6/4/24 7/3/23 1/2/22 
</script>
<script type="text/javascript" src="massSpring.js">
	var massSpring;
	</script>
<!--
///////////////////////////////////////////////////////////////////////////////////
// Below is the core WebGL initialization code.
///////////////////////////////////////////////////////////////////////////////////
-->
<script type="text/javascript">
var boxDrawer;
var pointDrawer;
var meshDrawer;
var ropeDrawer;

var canvas, gl;
var rotX=0, rotY=0, transY=0, transZ=3;
var MV, MVP; // view matrices

// Called once to initialize
function InitWebGL()
{
	// Initialize the WebGL canvas
	canvas = document.getElementById("canvas");
	canvas.oncontextmenu = function() {return false;};
	gl = canvas.getContext("webgl", {antialias: false, depth: true});	// Initialize the GL context
	if (!gl) {
		alert("Unable to initialize WebGL. Your browser or machine may not support it.");
		return;
	}
	
	// Initialize settings
	gl.clearColor(0,0,0,0);
	gl.enable(gl.DEPTH_TEST);
	
	// Initialize the programs and buffers for drawing	
	let whiteBox1x1 = [
		-1, -1, -1,
		-1, -1,  1,
		-1,  1, -1,
		-1,  1,  1,
		 1, -1, -1,
		 1, -1,  1,
		 1,  1, -1,
		 1,  1,  1 ];
	let whiteBox2x2 = whiteBox1x1.map( x => x*2 );
	boxDrawer   = new BoxDrawer( whiteBox1x1);
	pointDrawer = new PointDrawer();
	meshDrawer  = new MeshDrawer();
	ropeDrawer = new RopeDrawer(	
		[
            0, 1, 0, // Punto di inizio
            0, 0, 0  // Punto di fine
        ]);
	ropeDrawer2 = new RopeDrawer(
		[
		0.5, 1, 0, // Punto di inizio
		0.5, 0, 0  // Punto di fine
		]
	)
	
	// Set the viewport size
	UpdateCanvasSize();
}

// Called every time the window size is changed.
function UpdateCanvasSize()
{
	canvas.style.width  = "100%";
	canvas.style.height = "100%";
	const pixelRatio = window.devicePixelRatio || 1;
	canvas.width  = pixelRatio * canvas.clientWidth;
	canvas.height = pixelRatio * canvas.clientHeight;
	const width  = (canvas.width  / pixelRatio);
	const height = (canvas.height / pixelRatio);
	canvas.style.width  = width  + 'px';
	canvas.style.height = height + 'px';
	gl.viewport( 0, 0, canvas.width, canvas.height );
	UpdateViewMatrices();
}

function ProjectionMatrix( c, z, fov_angle=60 )
{
	var r = c.width / c.height;
	var n = (z - 1.74);
	const min_n = 0.001;
	if ( n < min_n ) n = min_n;
	var f = (z + 1.74);;
	var fov = 3.145 * fov_angle / 180;
	var s = 1 / Math.tan( fov/2 );
	return [
		s/r, 0, 0, 0,
		0, s, 0, 0,
		0, 0, (n+f)/(f-n), 1,
		0, 0, -2*n*f/(f-n), 0
	];
}

// return MV matrix
function GetModelViewMatrix(
  translationX,
  translationY,
  translationZ,
  rotationX,
  rotationY
) {
  // first column
  let a = Math.cos(rotationY);
  let c = -Math.sin(rotationY);
  // second column
  let e = Math.sin(rotationY) * Math.sin(rotationX);
  let f = Math.cos(rotationX);
  let g = Math.cos(rotationY) * Math.sin(rotationX);
  // third column
  let i = Math.sin(rotationY) * Math.cos(rotationX);
  let j = -Math.sin(rotationX);
  let k = Math.cos(rotationY) * Math.cos(rotationX);

  var mv = [
    a,
    0,
    c,
    0,
    e,
    f,
    g,
    0,
    i,
    j,
    k,
    0,
    translationX,
    translationY,
    translationZ,
    1,
  ];

  return mv;
}


function UpdateViewMatrices()
{
	var perspectiveMatrix = ProjectionMatrix( canvas, transZ );
	MV  = GetModelViewMatrix( 0, transY, transZ, rotX, rotY );
	MVP = MatrixMult( perspectiveMatrix, MV );
}

// This is the main function that handled WebGL drawing
function DrawScene()
{
	// Clear the screen and the depth buffer.
	gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
	
	// Draw the curve and then the line segments that connect the control points.
	var nrmTrans = [ MV[0],MV[1],MV[2], MV[4],MV[5],MV[6], MV[8],MV[9],MV[10] ];
	meshDrawer.draw( MVP, MV, nrmTrans );
	ropeDrawer.draw( MVP );
	ropeDrawer2.draw( MVP );
	if ( showBox.checked ) {
		boxDrawer.draw( MVP );
	}
	pointDrawer.draw( MVP );
	
}

// This is a helper function for compiling the given vertex and fragment shader source code into a program.
function InitShaderProgram( vsSource, fsSource, wgl=gl )
{
	const vs = CompileShader( wgl.VERTEX_SHADER,   vsSource, wgl );
	const fs = CompileShader( wgl.FRAGMENT_SHADER, fsSource, wgl );

	const prog = wgl.createProgram();
	wgl.attachShader(prog, vs);
	wgl.attachShader(prog, fs);
	wgl.linkProgram(prog);

	if (!wgl.getProgramParameter(prog, wgl.LINK_STATUS)) {
		alert('Unable to initialize the shader program: ' + wgl.getProgramInfoLog(prog));
		return null;
	}
	return prog;
}

// This is a helper function for compiling a shader, called by InitShaderProgram().
function CompileShader( type, source, wgl=gl )
{
	const shader = wgl.createShader(type);
	wgl.shaderSource(shader, source);
	wgl.compileShader(shader);
	if (!wgl.getShaderParameter( shader, wgl.COMPILE_STATUS) ) {
		alert('An error occurred compiling shader:\n' + wgl.getShaderInfoLog(shader));
		wgl.deleteShader(shader);
		return null;
	}
	return shader;
}

// Multiplies two matrices and returns the result A*B.
// The arguments A and B are arrays, representing column-major matrices.
function MatrixMult( A, B )
{
	var C = Array(16);
	for ( var i=0, m=0; i<4; ++i ) {
		for ( var j=0; j<4; ++j, ++m ) {
			var v = 0;
			for ( var k=0; k<4; ++k ) {
				v += A[j+4*k] * B[k+4*i];
			}
			C[m] = v;
		}
	}
	return C;
}

// Returns the inverse of the given 4x4 matrix
function MatrixInverse( m )
{
	var r = Array(16);
	
	var v_11_14__10_15 = m[11] * m[14] - m[10] * m[15];
	var v_10_15__11_14 = m[10] * m[15] - m[11] * m[14];
	var v__7_14___6_15 = m[ 7] * m[14] - m[ 6] * m[15];
	var v__6_11___7_10 = m[ 6] * m[11] - m[ 7] * m[10];

	var v__9_15__11_13 = m[ 9] * m[15] - m[11] * m[13];
	var v_11_13___9_15 = m[11] * m[13] - m[ 9] * m[15];
	var v__5_15___7_13 = m[ 5] * m[15] - m[ 7] * m[13];
	var v__7__9___5_11 = m[ 7] * m[ 9] - m[ 5] * m[11];
	
	var v_10_13___9_14 = m[10] * m[13] - m[ 9] * m[14];
	var v__9_14__10_13 = m[ 9] * m[14] - m[10] * m[13];
	var v__6_13___5_14 = m[ 6] * m[13] - m[ 5] * m[14];
	var v__5_10___6__9 = m[ 5] * m[10] - m[ 6] * m[ 9];
	
	var v_11_12___8_15 = m[11] * m[12] - m[ 8] * m[15];
	var v__8_15__11_12 = m[ 8] * m[15] - m[11] * m[12];
	var v__7_12___4_15 = m[ 7] * m[12] - m[ 4] * m[15];
	var v__4_11___7__8 = m[ 4] * m[11] - m[ 7] * m[ 8];
	
	var v__8_14__10_12 = m[ 8] * m[14] - m[10] * m[12];
	var v_10_12___8_14 = m[10] * m[12] - m[ 8] * m[14];
	var v__4_14___6_12 = m[ 4] * m[14] - m[ 6] * m[12];
	var v__6__8___4_10 = m[ 6] * m[ 8] - m[ 4] * m[10];
	
	var v__9_12___8_13 = m[ 9] * m[12] - m[ 8] * m[13];
	var v__8_13___9_12 = m[ 8] * m[13] - m[ 9] * m[12];
	var v__5_12___4_13 = m[ 5] * m[12] - m[ 4] * m[13];
	var v__4__9___5__8 = m[ 4] * m[ 9] - m[ 5] * m[ 8];

	r[ 0] = m[5] * (-v_11_14__10_15) + m[6] * (-v__9_15__11_13) + m[7] * (-v_10_13___9_14);
	r[ 1] = m[1] * (-v_10_15__11_14) + m[2] * (-v_11_13___9_15) + m[3] * (-v__9_14__10_13);
	r[ 2] = m[1] * (-v__7_14___6_15) + m[2] * (-v__5_15___7_13) + m[3] * (-v__6_13___5_14);
	r[ 3] = m[1] * (-v__6_11___7_10) + m[2] * (-v__7__9___5_11) + m[3] * (-v__5_10___6__9);
	
	r[ 4] = m[4] * ( v_11_14__10_15) + m[6] * (-v_11_12___8_15) + m[7] * (-v__8_14__10_12);
	r[ 5] = m[0] * ( v_10_15__11_14) + m[2] * (-v__8_15__11_12) + m[3] * (-v_10_12___8_14);
	r[ 6] = m[0] * ( v__7_14___6_15) + m[2] * (-v__7_12___4_15) + m[3] * (-v__4_14___6_12);
	r[ 7] = m[0] * ( v__6_11___7_10) + m[2] * (-v__4_11___7__8) + m[3] * (-v__6__8___4_10);
	
	r[ 8] = m[4] * ( v__9_15__11_13) + m[5] * ( v_11_12___8_15) + m[7] * (-v__9_12___8_13);
	r[ 9] = m[0] * ( v_11_13___9_15) + m[1] * ( v__8_15__11_12) + m[3] * (-v__8_13___9_12);
	r[10] = m[0] * ( v__5_15___7_13) + m[1] * ( v__7_12___4_15) + m[3] * (-v__5_12___4_13);
	r[11] = m[0] * ( v__7__9___5_11) + m[1] * ( v__4_11___7__8) + m[3] * (-v__4__9___5__8);

	r[12] = m[4] * ( v_10_13___9_14) + m[5] * ( v__8_14__10_12) + m[6] * ( v__9_12___8_13);
	r[13] = m[0] * ( v__9_14__10_13) + m[1] * ( v_10_12___8_14) + m[2] * ( v__8_13___9_12);
	r[14] = m[0] * ( v__6_13___5_14) + m[1] * ( v__4_14___6_12) + m[2] * ( v__5_12___4_13);
	r[15] = m[0] * ( v__5_10___6__9) + m[1] * ( v__6__8___4_10) + m[2] * ( v__4__9___5__8);

	var det = m[0]*r[0] + m[1]*r[4] + m[2]*r[8] + m[3]*r[12];
	for ( var i=0; i<16; ++i ) r[i] /= det;
	
	return r;
}

///////////////////////////////////////////////////////////////////////////////////
</script>


<!--
///////////////////////////////////////////////////////////////////////////////////
// Below are the main UI control functions.
///////////////////////////////////////////////////////////////////////////////////
-->
<script type="text/javascript">
var showBox;

window.onload = function() {
	showBox = document.getElementById('show-box');
	InitWebGL();
	lightView = new LightView();
	canvas.zoom = function( s ) {
		transZ *= s/canvas.height + 1;
		UpdateViewMatrices();
		DrawScene();
	}
	canvas.onwheel = function() { canvas.zoom(0.3*event.deltaY); }
	canvas.onmousedown = function() {
		if ( massSpring.mouseDown()) {
			canvas.ondblclick = null;
			return;
		}
		canvas.ondblclick = canvas.resetView;
		var cx = event.clientX;
		var cy = event.clientY;
		if ( event.ctrlKey ) {
			canvas.onmousemove = function() {
				canvas.zoom(5*(event.clientY - cy));
				cy = event.clientY;
			}
		} else if ( event.altKey ) {
			canvas.onmousemove = function() {
				let s = 1.5*transZ*(event.clientY - cy);
				transY -= s/canvas.height;
				UpdateViewMatrices();
				DrawScene();
				cy = event.clientY;
			}
		} else {
			canvas.onmousemove = function() {
				rotY += (cx - event.clientX)/canvas.width*5;
				rotX += (cy - event.clientY)/canvas.height*5;
				cx = event.clientX;
				cy = event.clientY;
				UpdateViewMatrices();
				DrawScene();
			}
		}
	}
	canvas.onmouseup = canvas.onmouseleave = function() {
		massSpring.mouseUp();	
		canvas.onmousemove = function() { massSpring.mouseMove(); }
	}
	canvas.onmousemove = function() { massSpring.mouseMove(); }
	canvas.resetView = function() {
		rotX = 0;
		rotY = 0;
		transY = 0;
		transZ = 3;
		UpdateViewMatrices();
		DrawScene();
	}
	
	// call for creation of ONE massSpring object
	// 0 = spPoly, 1 = spSmooth, 2 = spLow, 3 = box
	massSpring = new MassSpring(3);
	massSpring2 = new MassSpring(0);
	
	SetGravity  ( document.getElementById('gravity') );
	SetMass     ( document.getElementById('mass') );
	SetStiffness( document.getElementById('stiffness') );
	SetShininess( document.getElementById('shininess-exp') );

	DrawScene();
};
function WindowResize()
{
	UpdateCanvasSize();
	DrawScene();
}

function MousePos()
{
	return {
		x:  ( event.clientX / canvas.clientWidth  ) * 2 - 1,
		y: -( event.clientY / canvas.clientHeight ) * 2 + 1
	};
}

function ShowTexture( param )
{
	meshDrawer.showTexture( param.checked );
	DrawScene();
}

function LoadObj( param )
{
	if ( param.files && param.files[0] ) {
		var reader = new FileReader();
		reader.onload = function(e) {
			massSpring.setMesh( e.target.result );
		}
		reader.readAsText( param.files[0] );
	}
}

function LoadTexture( param )
{
	if ( param.files && param.files[0] ) {
		var reader = new FileReader();
		reader.onload = function(e) {
			var img = document.getElementById('texture-img');
			img.onload = function() {
				meshDrawer.setTexture( img );
				DrawScene();
			}
			img.src = e.target.result;
		};
		reader.readAsDataURL( param.files[0] );
	}
}

function SetTimeStepSize( param )
{
	var s = param.value;
	document.getElementById('timestep-value').innerText = s + " ms";
}

function SetGravity( param )
{
	var v = param.value;
	var s = v / 20;
	document.getElementById('gravity-value').innerText = s.toFixed( 2 );
	massSpring.gravity.y = -s;
}

function SetMass( param )
{
	var v = param.value;
	var s = v / 200;
	document.getElementById('mass-value').innerText = s.toFixed( 3 );
	massSpring.mass = s;
}

function SetStiffness( param )
{
	var v = param.value;
	var s = v / 20;
	document.getElementById('stiffness-value').innerText = s.toFixed( 2 );
	massSpring.stiffness = s;
}

function SetDamping( param )
{
	var v = param.value;
	var s = v / 20;
	document.getElementById('damping-value').innerText = s.toFixed( 2 );
	massSpring.damping = s;
}

function SetShininess( param )
{
	var exp = param.value;
	var s = Math.pow(10,exp/25);
	document.getElementById('shininess-value').innerText = s.toFixed( s < 10 ? 2 : 0 );
	meshDrawer.setShininess(s);
	DrawScene();
}

</script>

</head>

<body onresize="WindowResize()">
<div id="canvas-div"><canvas id="canvas"></canvas></div><div id="controls-div">
<div id="controls">
<div class="control-group"><canvas id="lightcontrol"></canvas><div id="lightcontrol-label">Light Direction</div></div>
<div class="control-group">
<div class="control"><input type="button" value="Start Simulation" onclick="massSpring.toggleSimulation(this)"></div>
<div class="control"><input type="button" value="Reset" onclick="massSpring.reset();DrawScene()"></div>
<div class="control"><span id="timestep-label">Time Step Size:</span><span class="value" id="timestep-value">20 ms</span><input id="timestep" type="range" min="1" max="100" value="20" oninput="SetTimeStepSize(this)" onchange="massSpring.restartSimulation()" ondblclick="this.value=20;this.oninput();this.onchange()"/></div>
<div class="control"><span id="gravity-label">Gravity:</span><span class="value" id="gravity-value">1</span><input id="gravity" type="range" min="0" max="100" value="20" oninput="SetGravity(this)" ondblclick="this.value=20;this.oninput()"/></div>
<div class="control"><span id="mass-label">Mass:</span><span class="value" id="mass-value">1</span><input id="mass" type="range" min="1" max="100" value="20" oninput="SetMass(this)" ondblclick="this.value=20;this.oninput()"/></div>
<div class="control"><span id="stiffness-label">Stiffness:</span><span class="value" id="stiffness-value">1</span><input id="stiffness" type="range" min="0" max="100" value="20" oninput="SetStiffness(this)" ondblclick="this.value=20;this.oninput()"/></div>
<div class="control"><span id="damping-label">Damping:</span><span class="value" id="damping-value">1.00</span><input id="damping" type="range" min="0" max="100" value="20" oninput="SetDamping(this)" ondblclick="this.value=20;this.oninput()"/></div>
</div>
<div class="control-group">
<div class="control"><input id="show-box" name="show-box" type="checkbox" onchange="DrawScene()" checked /><label for="show-box"> Show Box</label></div>
<div class="control"><input id="show-texture" name="show-texture" type="checkbox" onchange="ShowTexture(this)" checked /><label for="show-texture"> Show Texture</label></div>
<div class="control"><span id="shininess-label">Shininess:</span><span class="value" id="shininess-value">1</span><input id="shininess-exp" type="range" min="0" max="100" value="50" oninput="SetShininess(this)" ondblclick="this.value=50;this.oninput()"/></div>
<div class="control">OBJ model:<br/><input id="obj" type="file" onchange="LoadObj(this)" accept=".obj"/></div>
<div class="control">Texture image:<br/><input id="texture" type="file" onchange="LoadTexture(this)" accept="image/*"/></div>
<div class="control"><img id="texture-img" /></div>
</div>
</div>
</div>
</body>

</html>